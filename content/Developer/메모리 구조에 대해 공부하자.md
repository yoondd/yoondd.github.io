메모리는 왜 중요한가? - 하드웨어로 치자면, RAM이다
메모리는 ==휘발성==이다. 영속성을 가진 애들만 가지고있으면 프로그램 관리가 비효율적이다

***프로그램을 실행하게되면 OS는 메모리(RAM)에 공간을 할당한다***
OS는 그냥 컴퓨터 관리만 하지 특별한 일을 하지는 않는다
공간할당도 그 중에 하나다.

## 왜 휘발성 메모리가 필요하지?
껐다키면 깔끔하게 날라가야지


## CPU
==CPU== - 계산해주고 처리해주는 애다.

| 코어         | 스레드 | Ghz    |
| ---------- | --- | ------ |
| 중심. 뼈대. 건물 | 일꾼  | 넓이. 공간 |
> 예를들어 <1> 2코어 6스레드 2.3Ghz / <2> 1코어 1스레드 7Ghz 컴퓨터가 있다면, 어떤게 좋은걸까? 하나의 작업을 할거면 2번이 훨씬좋다. 멀티로 쓸게 아니라면말이다.

L2 캐시와 L3 캐시 -> 휘발성 임시 저장공간인데 용량은 적고 가격은 엄청비싸다. cpu안에 있기때문에 엄청 빠르고 좋지만 비싸고 귀하기때문에 여기공간을 막 쓰는건아니고 아주 중요한것만 담는다. 

RAM -> L2,L3보다 좀 멀어서 걸어가야되지만 그래도 용량이 좀 크기때문에 여기에 프로그램을 올려서 실행한다.

하드디스크 -> 엄~청 멀어. 대신 가격도 저렴하고 좋아. 


얘는 직접회로로 되어있다.
원리? 트랜지스터 - 자꾸 바뀐다 - 2진법으로 계속해서 계산
계산하려면 CPU에게 전달해야겠네?
하드디스크에있는 소스코드를 CPU한테 가져가야하는데, 너무 많네?
CPU랑 같이 메인보드에 있는 캐시공간에 변수나이런걸 다 넣을수는없잖아

![](https://i.imgur.com/EkpdsVc.png)

하드에서 CPU까지 너무 멀고 느려
RAM이랑 CPU는 가깝고 빨라

용량큰 소스코드는 하드에서 보관하고, 실행하는 순간에 컴파일러가 head부분에 변수랑 뭐랑 얼마나 공간이 필요한지 딱 계산해서 ==RAM==에 공간 할당해서 프로그램 실행할준비 딱한다. 


# CPU 스케줄링

> 가게에서 손님을 받는데 장사가 너무잘되서 사람들이 기다리고있다. 첫 손님이 한 5인분사가면 뒷사람들 너무 오래기다리니까 딱 1인분만 파는거야. 1인분 먹고 또 먹고싶으면 맨 뒤로가서 다시 대기하세요 고객님. 이라고 하는거다. - 이걸 ==기아현상==이라고한다. 
> CPU는 그래서 공평하게 처리하는데, 이를 우리는 ==라운드로빈(RR)==이라고한다. 

램이 물리적으로 갈 수는없고, 메모리에 담긴 주소값들이 줄을 서는거다. 







![](https://i.imgur.com/aaaOXpA.png)

# 메모리

변수와 메서드가 많이 올라가야한다
변수와 상수는 다르다

모든 언어의 메모리 할당방식이 똑같다
규칙 통일하면된다

1. ==코드영역==: 텍스트 영역이라고도 불린다. 내 코드가 여기있고 CPU가 여기서 하나씩 코드를 꺼내간다. 그냥 작동되는 다른 코드들을 말하는거다. *(메서드 흐름을 말하는 코드는 스택영역에있다)*
2. ==데이터영역==: static, 전역, 메인... 어디서든 접근이 가능할 수 있는 곳. 딱히 자료구조가 필요가없다. 왜냐면 꺼낼일이 없거든. 
3. ==스택(Stack)영역==: 힙영역의 주소를 받아온다<-메서드가 들어간다 / 번지(레퍼런스)를 저장한다. 스택형태라서 변수를 꺼내고 하는게 아주어렵다. 불편하다. 근데 왜 스택형태쓰냐고?- 그게 효율적이거든. 
	C->S->R->S->C 호출구조가 꼬이지않게 ==메서드는 스택구조로 가져간다== -> 일의 ***흐름***을 위해 이게 좋다.
	*==컴파일 시점에 크기가 결정된다==* -> 컴파일 언어다보니까 소스코드를 계속 해석해내면서 충분히 메서드가 몇개인지 크기를 결정할 수 있다. 총 몇단계인지 ==스택이라는건 원래 크기가 정해져있기==때문에 컴파일시점에 크기가 결정될 수 있다. 
	담기는 주요 내용은 ==지역변수, 파라미터(매개변수)==등이있다
	*메서드를 호출할 때마다 프레임을 추가하고 메서드가 종료되면 해당 프레임을 제거하는 동작을 수행한다*
	

4. ==힙(Heap)영역==: 큐 <- 변수, 실제 리터럴을 착착  넣어놓고 찾기편하게한다 / 칸칸이 나누어져있고 번지가 다 있다. 임시로 쓰는 변수.
	*==런타임 시점에 크기가 결정된다==* -> 실제 값이 결정되는 영역이다. 리터럴을 미리 지정할 수 없다보니까 size는 실행해야만 알 수 있다. ==동적으로 사이즈가 변경될 수 있다== 
	여기서 중요한 포인트는 ==동적할당==이라는거다. 


> 공부하면서 알게된건데, 예전에 리액트 useEffect공부할 때, return으로 ==클린업==해줬던 기억이 났다. 클린업도 메무리 누수를 방지하기위해서 개발자가 참조를 끊는 것이라고 볼 수 있다. 이벤트 리스너 같은 것들이 계속 켜져있으면 힙이 계속 낭비가 되니까, 사용이 끝난건 참조를 끊게되는거다. 참조를 끊으면 가비지컬렉션에 들어가는거다. 


- 2차원배열도 결국 메모리에서는 1차원배열이다. 
- 리터럴이나 순수한 값, 변수는 모두 힙영역에 차곡차곡 들어간다. 그래야지만 편하게 나올수가있거든. 

낮은주소:기계어와 가까운 수준(low-memory: 바이트코드쪽) / 높은주소
낮은데서 내려다보면 

static 붙은정적 애들이랑 전역변수, main들이 전역변수 위치에 들어간다.

![](https://i.imgur.com/XrdfBHN.png)

✅ 이렇게 예시 코드를 넣었는데 왜 getName()에는 접근을 못하는거야? 
왜냐면, 지역이 아니거든. 
근데, static을 넣으니까 되더라구. 어떻게 되냐고? 매모리의 데이터영역에들어가거든. 그래서 누구나 접근이 가능한거야. 



# 메모리 누수

힙-> 가변이다
엉덩이에 변이쌓임 = 힙에 변수가 쌓임
다 차버려서 못들어가면, 누수가 된다.. 
메모리 누수는 ==힙이 꽉찼을때 발생==한다


---

코드영역: 천상계 (아래를 모두 내려다본다)
데이터영역부터는 인간계.
전역변수/정적변수 데이터영역: 가장 높은애들. 아래애들을 쳐다보지를 않는다
힙영역, 스택영역: 아래애들은 데이터영역쪽을 참고할 수 있고 바라볼 수 있다
힙영역은 스택을 볼 필요도 없고.
스택영역은 물건을 갖다써야하니까 힙영역을 올려다본다




# 🙉메인메서드는 왜 항상 static이 붙어야하는거야? 

=> 모두가 그를 바라볼 수 있어야하잖아. 그리고 스택에 넣으면 큰일나. 어떻게 접근할거야 제일 아래에 깔릴텐데. 어차피 메서드이니까 스택에 있어야한다고 생각할 수 있지만, 절대 아니야. 



----


- 지역변수는 실제 값은 힙에. 그리고 메서드 자체는 스택에. (메모리 구조를 아니까 보이잖아!)


final -> ?? 생성자통해서 나중에 값이 들어가는거니까 -> 힙영역에 저장되는게 맞다 (밖에있을라면 static을 달던가)   ***final은 전역에 들어가는거 절대 아니다***


- 메모리의 구조를 아니까 `레파지토리.save()`가 그냥 member받아서 member배출했으니 수정한거라는게 보이네. 
- 주소를 받아서 주소안에 들어가서 수정하고, 반환으로 그냥 주소를 알려준거 뿐이야. (void해도돼 솔직히)
- 아 그래서 자꾸 save를 쓰는구나.


***프로그램이 실행되려면 ==운영체제==가 공간을 할당해준다 - RAM***



