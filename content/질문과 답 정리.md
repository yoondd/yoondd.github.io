

### Q. provider 동작 원리에 대해 설명해주세요. 
A. [[pub.sub]] 먼저 동기 비동기 블로킹 논블로킹 부터 봐라. [[동기.비동기.블로킹.논블로킹]]  / [[Rendering 동작방식]]


### Q. default fail은 언제 쓰나요?(왜 오버로딩까지 해요? 그냥 쓰면되는거아니에요?)
A. [[default fail]]


### Q. @Operation 이라는 어노테이션? 
A. swagger 주석이다


### Q. 모델인데 builder패턴 적용할건데 왜 setter필요해? 난 잘이해가 안가는데? 혹시 requestbody자체가 안되나? 없으면?
A. 맞아. 사용자가 입력하는 것들(request)은 반드시 setter가 필요하다. 내가 서비스에서 직접 set하기 싫어서 쓰는 builder는 그저 내가 하는일을 대신하는 것이야. setter를 버릴수가 없는건 바로 Request이다. 


### Q. 단 하나의 필드라면 이건 직접 받는거보다 모델로 만드는게 나은가? 
A. 바뀔수밖에없으니까 모델로 받아. 언제 바뀔지 모르거든. 유지보수 관점으로 생각해라. 서비스에 등록할때 그럼 하나밖에 없더라도 모델으로 넘기는것이 좋은가? 그렇다. 유지보수를 생각했을때 필드가 하나밖에 없더라도 그렇게 넘기는 것이 좋다. 


### Q. `@ResponseStatus(HttpStatus.BAD_REQUEST)` 이게 왜 있어야할까?
A. http통신을 보고 curl을 이해해면된다. header에 붙어가는 것이다.


### Q. 이런 내용은 웹에만 국한되어서 백엔드로만 일할 수 있나요?
A. 아니요.  어드바이스를 예로 들어볼까? "던진거 들었어. 그리고 주워들어서 조언을 해준다 - 조언 후 처리" 이건 마치 뺏어서 처리하는 축구의 인터셉트와도 같다. 어드바이스도 던질때 뺏어가지고 처리한다.

게임서버에서 가장 많이 쓰이는게. 인터셉트. 엄청나게 쓰인다.이벤트끼리 충돌이 일어나니까말이다. 즉, 이런 개념들은 프로그래밍 공통이다. 백엔드가 아니라 프로그래밍을 배우는것이다


### Q. 원본데이터 그대로 왜 보내지 않는가?
원본데이터에 무엇이 있는줄 알아. 보안적으로도 아주 위험한 일인거지. 내가 가공해서 보여주고싶은 데이터만 보여주는거야. 



### Q. baseframe 복사해다가 다른 프로젝트시작하는 방법
아직 우리가 배우지 않은거야. 좀 더 공부하다보면 알게될 것이야
[[baseframe기반으로 프로젝트 생성]]


### Q. dto/dao/vo의 차이점? 우리가 공부하는건 전부 dto인가? springboot에서는 dao를 사용하지않는것인가?
시큐리티 영상에 나오니까 한번 확인해보거라.



### 플러터 공부하기

- 배울 수 있는 곳이 적다
- 외국에 도입된지 3~4년되어 지금 배웠을때의 가치가 높다
- 채용공고가 점점 늘고있다
- 리액트 네이티브보다 플러터를 더 선호한다(리액트 네이티브는 느리거든)
- IOS와 안드로이드, 웹까지 모두 가능.

### Q. CSV 대량파일 DB에 등록하기
https://www.youtube.com/@mungcoding/videos


## Q. implements와 extends

| 구분    | extends          | implements             |
| ----- | ---------------- | ---------------------- |
| 대상    | 클래스(일반/추상) → 클래스 | 인터페이스 → 클래스            |
| 상속/구현 | 상속(기능 및 속성 물려받음) | 구현(메서드 선언만 물려받고 직접 구현) |
| 다중 사용 | 단일 상속만 가능        | 여러 인터페이스 동시 구현 가능      |
| 오버라이딩 | 선택적(필요 시 오버라이딩)  | 필수(모든 메서드 구현 필요)       |
**인터페이스는 다른 인터페이스를 implements로 받을 수 없습니다.**

- **implements** 키워드는 "클래스가 인터페이스를 구현할 때" 사용합니다.
- **extends** 키워드는 "인터페이스가 다른 인터페이스를 상속받을 때" 사용합니다.

즉,

- 클래스 → 인터페이스 : implements 사용
- 인터페이스 → 인터페이스 : extends 사용
- 클래스 → 클래스 : extends 사용