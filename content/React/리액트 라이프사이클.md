12:57한번 그리고 버리고 새로 그리는거면 라이프사이클이 필요없다.
리액트는 SPA이기때문에 필요하다
한페이지 안에서 등장, 수정, 죽여버리는 것들이 일어나다보니 라이프사이클이 필요하다

리액트는 모든게 *컴포넌트*다.


# 클래스 방식의 라이프사이클

함수 구조가 더 좋긴한데, 일단은 최초에 만들었던 클래스 방식을 먼저 이해하자.
(함수형을 더 권장하기는 하지만 먼저 이걸 이해해야한다)

![](https://i.imgur.com/9pAeAfB.png)

위 그림은 사실 색으로 구분하자면 두가지 영역으로 나뉜다.

#### 회색영역
메모리 내부에서의 이야기
Render단계라고 이야기하는데, 이부분은 V-DOM이라고 생각하면된다,
보이지 않는 메모리 영역에서의 이야기들이 등장한다
V-DOM은 그래프로 되어있다. (다시말해 유사배열이다)
여기서의 ==render==는 그래프에 소스코드를 업데이트 시키는 걸로 끝난다.

#### 흰색영역
실제로 보여지는 내용
DOM으로 바뀌어지는 영역이라고 보면된다
가지고있는 소스코드로 실제 DOM을 만드는 과정이다 - ==React DOM 및 refs 업데이트==를 진행해야한다는 것이다.


---

자, 위 아래의 구분을 봤다면 이제는 큰 틀로 세단계를 나누어보자.

*생성될 때 (탄생, 마운팅) - 업데이트 할 때 (성장, 업데이팅) - 제거할 때 (죽음, 언마운팅)*
(올라타는 것이 마운팅이다..... 강아지의 마운팅.......😅)

x축: 전체적인 시간
y축: 컴포넌트 내에서의 시간


### 생성
1. 생성자가 필요하다. - new 컴포넌트
	생성에 필요한 값이 무엇인지를 판단해서 그다음 단계에 말을 한다

2. ==static getDerivedStateFromProp== - 값 할당
	static이라는 말이 붙었네. 
	`props`로 받아 온 값을 `state`에 동기화시키는 용도로 사용한다.
	(마치 클래스의 멤버변수처럼 말이다.)
	--> 이영역은 값을 나중에 업데이트할 때 그대로 할당된 값을 수정해서 사용할 수 있다.
	바인딩 하면,
		new props: 값을 확인
		setState: 값을 세팅하고
		forceUpdate: 강제 업데이트

3. render진행
	**render라는것은 유사배열(그래프)인 V-DOM에다가 소스코드를 업데이트 시키는 과정이다**

4. componentDidMount 끝.


###  업데이트
1. ==static getDerivedStateFromProp== - 값을 새로 넣겠다
2. ==shouldComponentUpdate== 변경된 값이 있는지 확인. 
	static영역에 올라가 있기때문에 새로운 값과 기존의 값을 비교할 수 있다.

3. 업데이트할 내용이 있으면 render를 진행한다

4. 여기서 완전 포인트는 ==getSnapShotBeforeUpdate== 이부분이다.
	V-DOM에서 그래프에 소스코드는 업데이트했지만 아직 DOM으로 변환하기 직전에 그 전의 상태를 딱 찍어두는거다. -백업
	- JS는 실행중에 오류가 날 수 있다. DOM복구가 필요할 수 있다. 혹시나 잘못되었을 때 이전 상태로 되돌릴 수 있게 스냅샷을 찍어둔다. 매번 이렇게 백업을 진행한다. 버전관리를 하겠다는건 아니구; 그냥 이전으로만 복구할 수 있으면된다

5. V-DOM과 DOM을 연결해주는 작업이 바로 ==refs업데이트==다
	이게 왜 필요하냐고? - 나중에 클릭했을때 사용자가 클릭하는건 그저 DOM이야. 그런데 그걸 눌렀을때 무얼해야하는가에 대한 함수같은것들은 어디에있냐면 V-DOM이 가지고 있어. DOM은 그걸 모른다구. 그러니까 그것들을 서로 연결고리로 걸어줘야하는데 그걸 행하는게 바로 refs 업데이트인거야.

6. componentDidUpdate 끝.


### 제거
제거할 때는 뭐 하는게 없다.
죽기전에 뭐할지를 우리가 작성할 수도 있지만, 그런게없으면 아무것도 없이 그냥 삭제되는거다. 


```jsx
import React, { Component } from "react";

class UserListClass extends Component {
  state = {
    loading: true,
    users: [],
  };

  componentDidMount() {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then((response) => response.json())
      .then((users) => this.setState({ users, loading: false }));
  }

  render() {
    const { loading, users } = this.state;
    if (loading) return <div>Loading...</div>;
    return (
      <ul>
        {users.map((user) => (
          <li key={user.id}>{user.name}</li>
        ))}
      </ul>
    );
  }
}
```

- 리턴이 없는 클래스는 이런식으로 render()가 별도로 필요하다
- 심지어 훅도 사용할 수 없어서 내가 직접 만들어야한다



여기까지, 과정이 정말 많다. 애초에 길 수 밖에 없고, 느릴 수 밖에 없다는건 어쩔 수 없네..
생성되고나서 다시 업데이트할때 과정도 처음부터 쭉쭉 해야되니까 느려....
안되겠다. 자바스크립트는 프로토타입 언어이니까. 함수로 바꿔버리자!!




# 함수 방식의 라이프사이클


![](https://i.imgur.com/w9gfi9Y.png)


그래서 준비했습니다.

#### 일단 static부터 빼버렸네??
함수방식의 라이프사이클에서는 어차피 호이스팅이 된단 말이야. 그러니까 정적영역에 올리지 않아도 괜찮았어. 

함수를 생성할때 넘기는 파라미터는 사실 생성자의 역할을 한다고 볼 수 있다
`abc(a,b){}`

#### 함수는 유사배열 그대로 가지고 render하면된다

==자바스크립트의 모든 기능을 다 그대로 사용해서 구현한 함수형 컴포넌트는 훨씬 효율적이다==

여기서 알 수 있는것은..
자바스크립트를 쓰면서 예쁘게 클래스로 포장할 필요가 하나도 없다라는거다
그러면 굳이 한번 더 감싸서 쓰겠다는 말이거든.


#### 함수형컴포넌트에서는 반복되는 로직을 커스텀 훅으로 묶어서 처리한다.

클래스는 틀을 가지고있어야하고
함수는 그저 부르기만하면된다
자바스크립트의 대부분은 그냥 함수라고 생각하면된다



