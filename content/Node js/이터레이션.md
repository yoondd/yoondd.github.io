
데이터 컬렉션을 순회하기위해 만들어진 규칙이다.
이터레이션 프로토콜을 준수한 객체는 for...of문으로 순회할 수 있고 spread문법의 피연산자가 될 수 있다.

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다. 


```js

[Symbol.iterator]()

//위는 아래를 리턴한다

{
	next(){
		return {
			value: any,
			done: boolean
		};
	}
}


```


# 이터러블

이터러블 프로토콜을 준수한 객체를 이터러블이라고 한다.  ==준수했다는 것은 Symbol.iterator()를 가졌다는 뜻이다==
이터러블은 Symbol.iterator메서도를 구현하거나 프로토타입 체인에 의해 상속한 객체를 말한다. 

```js
const array = [1,2,3];
console.log(Symbol.iterator in array);

for(const item of array){
	console.log(item);
}
```

- for...of 문 사용가능
- Spread (값을 뿌리는 것) 문법 대상으로 사용 가능

위 코드는 이터러블이기때문에 for...of문으로 돌리는 것이 가능한 것을 볼 수 있다. 
반면에 객체같은건 순서보증이 되지않기때문에 안된다. 



# 이터레이터

이터레이터 프로토콜을 next메서드를 자동으로 갖는다.
next메서드를 호출하면 이터러블을 순회하면서 value, done프로퍼티를 갖는 객체를 반환한다.

```js
const array = [1, 2, 3]; 
const iterator = array[Symbol.iterator](); 
console.log('next' in iterator); 

let iteratorResult = iterator.next(); 
console.log(iteratorResult); // {value: 1, done: false}
```

```js
const array = [1,2,3];
console.log(Symbol.iterator in array);
console.log(Symbol.iterator);

for(const item of array){
	console.log(item);
}

console.log("******");

const iterator = array[Symbol.iterator]();
console.log('next' in iterator);
console.log(iterator);

// console.log(iterator.next());
// console.log(iterator.next());
// console.log(iterator.next());
// console.log(iterator.next());

let next = iterator.next();
while(!next.done){
	console.log(next.value);
	next = iterator.next();
}
```

위처럼 while문으로 반복문처럼 구현할 수도 있다
이 내용은 내가 처음으로 이터레이터를 공부했을때 엄청 궁금해서 찾아봤던건데 오랜만에 하니까 재밌다.



# 빌트인 이터러블

Array, 
String, 
Map, 
Set, 
TypedArray(Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array), 
DOM data structure(NodeList, HTMLCollection), 
Arguments

위의 내용이 ES6에서 지원하는 빌트인 이터러블이다.
- U가 붙어있는건 unsigned를 의미한다. 

```js

// 문자열은 이터러블이다. 
const string = 'hi'; 
// 이터러블은 Symbol.iterator 메소드를 소유한다. 
// Symbol.iterator 메소드는 이터레이터를 반환한다. 
iter = string[Symbol.iterator](); 

// 이터레이터는 next 메소드를 소유한다. 
// next 메소드는 이터레이터 리절트 객체를 반환한다. 
console.log(iter.next()); // {value: "h", done: false} 
console.log(iter.next()); // {value: "i", done: false} 
console.log(iter.next()); // {value: undefined, done: true} 

// 이터러블은 for...of 문으로 순회 가능하다. 
for (const letter of string) { console.log(letter); }
```



# for...of 문의 동작방식

```js
const it2 = [ 1, 2, 3];
const itt = it2[Symbol.iterator]();

for(;;){
    const res = itt.next();
    if(res.done) break;

    console.log(res);
}
```

참고로 여기서for(;;)이부분은 초기화, 조건, 증감을 모두 생략한 상태로 무한루프를 말한다.




# 커스텀 이터러블

일반 객체는 이터러블이 아니기떄문에 Symbol.iterator 메서드가 없다. 
그래서 직접 만들었다. 

굉장히 이해하기 힘들었는데, 재미있는 코드였다.
피보나치수열을 만들기위한 아래 코드를 분석해본다.

```js

const fibonacci = {
    [Symbol.iterator](){
        let [ pre, current ] = [ 0, 1 ];
        const max = 100; // 최대
        
        return {
            next(){
                [pre, current] = [current, pre+current];
                return{
                    value: current,
                    done: current >= max
                }
            }
        }
    }
}


for( const num of fibonacci ) {
    console.log(num);
}
```


이렇게 피보나치 수열을 커스텀해서 사용한다
아래에있는 for ..of 문에서 fibonacci의 Symbol.iterator을 찾을테니까 위에서 정의해준다.
거기서 보면 return에  next()에,  return이 있고, 그 안에 value가 있다.
그걸 아래에있는 for...of문에서 num으로 받는것이다.


놀랍게도, 이런것도 가능하다
```js
const result = [...fibonacci];
console.log(result);

const [first, second, ...rest] = fibonacci;
console.log(first, second, rest);
```




😝
공부를 하다보니까, 많은 커스텀 이터러블이 비슷하게 생겼다
너무 어려우면 대략의 형태를 그냥 익혀두는 것도 좋을 것 같다

```js
const myIterable = {
    data: [10, 20, 30],
    [Symbol.iterator]() {
        let index = 0;
        const data = this.data;
        return {
            next() {
                if (index < data.length) {
                    return { value: data[index++], done: false };
                } else {
                    return { value: undefined, done: true };
                }
            },
        };
    },
};

for (const value of myIterable) {
    console.log(value); // 출력: 10, 20, 30
}
```


