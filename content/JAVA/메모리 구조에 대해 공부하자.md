메모리는 왜 중요한가? - 하드웨어로 치자면, RAM이다

==CPU== - 직접회로.  원리? 트랜지스터 - 자꾸 바뀐다 - 2진법으로 계속해서 계산
계산하려면 CPU에게 전달해야겠네?
하드디스크에있는 소스코드를 CPU한테 가져가야하는데, 너무 많네?
CPU랑 같이 메인보드에 있는 캐시공간에 변수나이런걸 다 넣을수는없잖아

![](https://i.imgur.com/EkpdsVc.png)


하드에서 CPU까지 너무 멀고 느려
RAM이랑 CPU는 가깝고 빨라

용량큰 소스코드는 하드에서 보관하고, 실행하는 순간에 컴파일러가 head부분에 변수랑 뭐랑 얼마나 공간이 필요한지 딱 계산해서 ==RAM==에 공간 할당해서 프로그램 실행할준비 딱한다. 

![](https://i.imgur.com/aaaOXpA.png)

# 메모리

변수와 메서드가 많이 올라가야한다
변수와 상수는 다르다
]
모든 언어의 메모리 할당방식이 똑같다
규칙 통일하면된다

1. ==코드영역==
2. ==데이터영역==: static, 전역, 메인...
3. ==스택영역==: 힙영역의 주소를 받아온다<-메서드가 들어간다 / 번지(레퍼런스)를 저장한다. 스택형태라서 변수를 꺼내고 하는게 아주어렵다. 불편하다. 근데 왜 스택형태쓰냐고?- 그게 효율적이거든. 
	C->S->R->S->C 호출구조가 꼬이지않게 ==메서드는 스택구조로 가져간다== 
	*==컴파일 시점에 크기가 결정된다==* -> 컴파일 언어다보니까 소스코드를 계속 해석해내면서 충분히 메서드가 몇개인지 크기를 결정할 수 있다. 

4. ==힙영역==: 큐 <- 변수, 실제 리터럴을 착착  넣어놓고 찾기편하게한다 / 칸칸이 나누어져있고 번지가 다 있다
	*==런타임 시점에 크기가 결정된다==* -> 실제 값이 결정되는 영역이다. 리터럴을 미리 지정할 수 없다보니까 size는 실행해야만 알 수 있다.

- 2차원배열도 결국 메모리에서는 1차원배열이다. 
- 리터럴이나 순수한 값, 변수는 모두 힙영역에 차곡차곡 들어간다. 그래야지만 편하게 나올수가있거든. 

낮은주소:기계어와 가까운 수준(low-memory: 바이트코드쪽) / 높은주소
낮은데서 내려다보면 

static 붙은정적 애들이랑 전역변수, main들이 전역변수 위치에 들어간다.

![](https://i.imgur.com/XrdfBHN.png)

✅ 이렇게 예시 코드를 넣었는데 왜 getName()에는 접근을 못하는거야? 
왜냐면, 지역이 아니거든. 
근데, static을 넣으니까 되더라구. 어떻게 되냐고? 매모리의 데이터영역에들어가거든. 그래서 누구나 접근이 가능한거야. 



# 메모리 누수

힙-> 가변이다
엉덩이에 변이쌓임 = 힙에 변수가 쌓임
다 차버려서 못들어가면, 누수가 된다.. 
메모리 누수는 ==힙이 꽉찼을때 발생==한다


---

코드영역: 천상계 (아래를 모두 내려다본다)
데이터영역부터는 인간계.
전역변수/정적변수 데이터영역: 가장 높은애들. 아래애들을 쳐다보지를 않는다
힙영역, 스택영역: 아래애들은 데이터영역쪽을 참고할 수 있고 바라볼 수 있다
힙영역은 스택을 볼 필요도 없고.
스택영역은 물건을 갖다써야하니까 힙영역을 올려다본다




# 🙉메인메서드는 왜 항상 static이 붙어야하는거야? 

=> 모두가 그를 바라볼 수 있어야하잖아. 그리고 스택에 넣으면 큰일나. 어떻게 접근할거야 제일 아래에 깔릴텐데. 어차피 메서드이니까 스택에 있어야한다고 생각할 수 있지만, 절대 아니야. 





