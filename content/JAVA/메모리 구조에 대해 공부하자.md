메모리는 왜 중요한가? - 하드웨어로 치자면, RAM이다

==CPU== - 직접회로.  원리? 트랜지스터 - 자꾸 바뀐다 - 2진법으로 계속해서 계산
계산하려면 CPU에게 전달해야겠네?
하드디스크에있는 소스코드를 CPU한테 가져가야하는데, 너무 많네?
CPU랑 같이 메인보드에 있는 캐시공간에 변수나이런걸 다 넣을수는없잖아

![](https://i.imgur.com/EkpdsVc.png)


하드에서 CPU까지 너무 멀고 느려
RAM이랑 CPU는 가깝고 빨라

용량큰 소스코드는 하드에서 보관하고, 실행하는 순간에 컴파일러가 head부분에 변수랑 뭐랑 얼마나 공간이 필요한지 딱 계산해서 ==RAM==에 공간 할당해서 프로그램 실행할준비 딱한다. 

![](https://i.imgur.com/aaaOXpA.png)

# 메모리

변수와 메서드가 많이 올라가야한다
변수와 상수는 다르다

모든 언어의 메모리 할당방식이 똑같다
규칙 통일하면된다

1. ==코드영역==: 텍스트 영역이라고도 불린다. 내 코드가 여기있고 CPU가 여기서 하나씩 코드를 꺼내간다.
2. ==데이터영역==: static, 전역, 메인...
3. ==스택영역==: 힙영역의 주소를 받아온다<-메서드가 들어간다 / 번지(레퍼런스)를 저장한다. 스택형태라서 변수를 꺼내고 하는게 아주어렵다. 불편하다. 근데 왜 스택형태쓰냐고?- 그게 효율적이거든. 
	C->S->R->S->C 호출구조가 꼬이지않게 ==메서드는 스택구조로 가져간다== 
	*==컴파일 시점에 크기가 결정된다==* -> 컴파일 언어다보니까 소스코드를 계속 해석해내면서 충분히 메서드가 몇개인지 크기를 결정할 수 있다. 
	담기는 주요 내용은 ==지역변수, 파라미터(매개변수)==등이있다

4. ==힙영역==: 큐 <- 변수, 실제 리터럴을 착착  넣어놓고 찾기편하게한다 / 칸칸이 나누어져있고 번지가 다 있다
	*==런타임 시점에 크기가 결정된다==* -> 실제 값이 결정되는 영역이다. 리터럴을 미리 지정할 수 없다보니까 size는 실행해야만 알 수 있다. ==동적으로 사이즈가 변경될 수 있다== 
	여기서 중요한 포인트는 ==동적할당==이라는거다. 


> 공부하면서 알게된건데, 예전에 리액트 useEffect공부할 때, return으로 ==클린업==해줬던 기억이 났다. 클린업도 메무리 누수를 방지하기위해서 개발자가 참조를 끊는 것이라고 볼 수 있다. 이벤트 리스너 같은 것들이 계속 켜져있으면 힙이 계속 낭비가 되니까, 사용이 끝난건 참조를 끊게되는거다. 참조를 끊으면 가비지컬렉션에 들어가는거다. 


- 2차원배열도 결국 메모리에서는 1차원배열이다. 
- 리터럴이나 순수한 값, 변수는 모두 힙영역에 차곡차곡 들어간다. 그래야지만 편하게 나올수가있거든. 

낮은주소:기계어와 가까운 수준(low-memory: 바이트코드쪽) / 높은주소
낮은데서 내려다보면 

static 붙은정적 애들이랑 전역변수, main들이 전역변수 위치에 들어간다.

![](https://i.imgur.com/XrdfBHN.png)

✅ 이렇게 예시 코드를 넣었는데 왜 getName()에는 접근을 못하는거야? 
왜냐면, 지역이 아니거든. 
근데, static을 넣으니까 되더라구. 어떻게 되냐고? 매모리의 데이터영역에들어가거든. 그래서 누구나 접근이 가능한거야. 



# 메모리 누수

힙-> 가변이다
엉덩이에 변이쌓임 = 힙에 변수가 쌓임
다 차버려서 못들어가면, 누수가 된다.. 
메모리 누수는 ==힙이 꽉찼을때 발생==한다


---

코드영역: 천상계 (아래를 모두 내려다본다)
데이터영역부터는 인간계.
전역변수/정적변수 데이터영역: 가장 높은애들. 아래애들을 쳐다보지를 않는다
힙영역, 스택영역: 아래애들은 데이터영역쪽을 참고할 수 있고 바라볼 수 있다
힙영역은 스택을 볼 필요도 없고.
스택영역은 물건을 갖다써야하니까 힙영역을 올려다본다




# 🙉메인메서드는 왜 항상 static이 붙어야하는거야? 

=> 모두가 그를 바라볼 수 있어야하잖아. 그리고 스택에 넣으면 큰일나. 어떻게 접근할거야 제일 아래에 깔릴텐데. 어차피 메서드이니까 스택에 있어야한다고 생각할 수 있지만, 절대 아니야. 



----


- 지역변수는 실제 값은 힙에. 그리고 메서드 자체는 스택에. (메모리 구조를 아니까 보이잖아!)


final -> ?? 생성자통해서 나중에 값이 들어가는거니까 -> 힙영역에 저장되는게 맞다 (밖에있을라면 static을 달던가)   ***final은 전역에 들어가는거 절대 아니다***


- 메모리의 구조를 아니까 `레파지토리.save()`가 그냥 member받아서 member배출했으니 수정한거라는게 보이네. 
- 주소를 받아서 주소안에 들어가서 수정하고, 반환으로 그냥 주소를 알려준거 뿐이야. (void해도돼 솔직히)
- 아 그래서 자꾸 save를 쓰는구나.


***프로그램이 실행되려면 ==운영체제==가 공간을 할당해준다 - RAM***



