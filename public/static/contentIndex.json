{"Cron":{"slug":"Cron","filePath":"Cron.md","title":"Cron","links":[],"tags":[],"content":"크론(Cron)은 유닉스 계열 운영 체제에서 사용되는 시간 기반 작업 스케줄러로 사용자가 지정한 시간에 명령어 또는 스크립트를 자동으로 실행하도록 예약할 수 있는 도구다. 이건 반복적인 작업을 자동화하는 데 아주 유용하다.\n어쩌다가 알았는가?\n사실 크론의 존재조차 알지못했는데, 거래처에서 요구하는기능을 구현하기위해 sql문이 일정시간간격으로 들어가야하는 작업이 생겼다. 어떻게 해야할지 알아보는데 카페24 리셀러 관리자의 db건드는 권한이 그리 크지않아서 크론을 이용하기로했다.\n주요 특징\n자동화된 작업 스케줄링: 특정 시간, 날짜, 주기적으로 작업을 실행할 수 있다.\n\nCrontab 파일: 크론 작업을 설정하는 파일로, 각 줄에 작업 스케줄과 실행할 명령어를 정의한다.\n주요 활용 사례:\n\n시스템 유지보수\n데이터 백업\n로그 정리\n주기적 보고서 생성\n\n\n\nCrontab 표현식\n크론의 표현식은 정규식 형태로 작성된다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n필드명값의 허용 범위예시초 (Seconds)0–59*/5 (5초마다)분 (Minutes)0–5915,45 (15분, 45분에 실행)시 (Hours)0–230 9 (오전 9시에 실행)일 (Day)1–311-7 (매월 1일부터 7일까지)월 (Month)1–12 또는 JAN–DECJAN,MAR (1월, 3월에 실행)요일 (Weekday)0–6 또는 SUN–SATMON-FRI (월~금 실행)연도 (Year)생략 가능 또는 1970–20992025\n특수문자를 사용하여 복잡한 일정도 설정할 수 있다\n\n*: 모든 값\n,: 특정 값들\n-: 범위 지정\n/: 간격 설정\n?: 특정 값 없음\nL: 마지막 날 또는 요일\nW: 가장 가까운 평일\n#: 몇째 주의 특정 요일\n\n외부 크론\n서버 내에 접근하는게 좀 어렵길래 나는 외부 서비스로 정기적인 내용을 진행할 수 있도록 연동했다\n쉽게 말하면, 특정 시간마다 외부 서비스가 내가 지정한 URL(예: wp-cron.php)을 호출해서 작업을 자동으로 실행하게 만드는 거다\n내가 가지고있는 웹호스팅의 권한 한계때문에 간단히 외부 서비스를 사용했다고 보면된다.\n뭐가 좋은가?\n\n서버 리소스를 아껴줌\n내부 크론은 보통 웹사이트 방문자에 의해 트리거되는데, 방문자가 없으면 작업이 늦게 실행될 수도 있다. 외부 크론은 이런 문제 없이 정확히 설정한 시간에 실행돼서 서버 부하를 완전 줄여준다.\n정확한 실행 시간\n외부 크론은 설정한 주기에 맞춰 딱딱 실행돼서 작업 누락이나 지연 걱정을 할 필요가없다\n사용하기 쉬움\n대부분의 외부 크론 서비스는 직관적인 UI를 제공해서 설정하고 관리하기 편리하다\n추가 기능 제공\n작업 실패 시 알림 보내기, 재시도 기능, 실행 로그 기록 같은 부가 기능도 지원하는데…(써보지는못했다)\n\n나는 무료로 제공하는 cron-job.org을 이용했다."},"Node-js/1.-Node-js":{"slug":"Node-js/1.-Node-js","filePath":"Node js/1. Node js.md","title":"1. Node js","links":[],"tags":[],"content":"node js의 등장으로, 원래 웹브라우저만 제어하던 javascript가 컴퓨터 자체를 제어하기 시작한다.\n재생목록\nwww.youtube.com/playlist\nproject folder\n/Users/yunhyegyeong/Developer/myNode\n목표:  node js application제작\n각각의 스텝마다 node js가 가지고있는 기능을 실행시킨다"},"Node-js/10.-데이터를-파일로-쓰기--and--redirection":{"slug":"Node-js/10.-데이터를-파일로-쓰기--and--redirection","filePath":"Node js/10. 데이터를 파일로 쓰기 & redirection.md","title":"10. 데이터를 파일로 쓰기 & redirection","links":[],"tags":[],"content":"fs.writeFile()메서드를 사용한다\nrequest.on(&#039;end&#039;,()=&gt;{\n\t//더이상 들어올 정보가 없다면,\n\tconst post = qs.parse(body); //모든 정보 객체화.\n\tconsole.log(post);\n\tconst bodyTitle = post.title;\n\tconst bodyDescription = post.description;\n\tfs.writeFile(`data/${bodyTitle}`, bodyDescription, &#039;utf8&#039;, (err)=&gt;{\n\t\n\t  response.writeHead(302,{Location:`/?=id=${bodyTitle}`});\n\t  response.end();\n\t})\n  });\n\n\ndata폴더에 title과 같은 이름의 파일을 생성한다\n\n\n내용은 description을 넣는다\n\n\nwriteHead의 302, {Location: &quot;&quot;}을 이용해서 리다이렉션까지 완성한다\n\n"},"Node-js/2.-URL":{"slug":"Node-js/2.-URL","filePath":"Node js/2. URL.md","title":"2. URL","links":[],"tags":[],"content":"웹애플리케이션을 구현하는 node js의 아주 중요한 테크닉.\n\nnode 에서 main.js를 실행해달라고 서버를 켜기\n3000번 포트에 나오는 내용은 정적파일이라고 볼수 있다.\n만약 1억개라면 1억개의 페이지를 만들어야겠네..\n똑같은 파일을 요청해서 받아도 뒤에 나오는 값을 달리해서 서로 다른 페이지를 받을수 있지않을까? — 무엇으로? — url의 형식에 대해 정확히 알아서 말이야.\n\nopentutorials.org:3000/main\n위 샘플 url을 분석해보자.\n\nhttp부분은 프로토콜 통신규칙. 즉, 사용자가 서버에 접속할때 어떤방식으로 접속할 것인가에 대한 이야기다. http는 웹브라우저와 웹서버가 서로 데이터를 주고받기 위해 만든 통신규칙을 말한다. 만약에 ftp를사용하면 프로토콜 통신규칙에는 ftp가 나오겠지\nopentutorial.org쪽은 도메인네임이라고도 하고, 호스트라고도 부르는데, 인터넷에 접속되어있는 각각의 컴퓨터를 말한다. 컴퓨터를 가리키는 주소라고 볼 수 있다.\n:3000은 포트번호라고 한다. 한대의 컴퓨터안에 여러개의 서버가 있을 수가 있는데, 그중에 어떤 서버와 통신할지를 말해준다. main.js 에서 우리가 listen을 3000이라고했기때문에 3000번 포트로 접속할 수 있게된다. 웹서버는 기본값이 80이라서, 생략하면 80번 포트로 들어가게 되어있다\nmain은 path이다. 접속할 때 어떤 디렉토리의 어떤 파일로 접근하는지를 말해준다\nid~~~~ 이 뒤쪽은 query string이다. 바로 우리의 주인공이다. 즉, 쿼리스트링의 값을 변경하면 우리가 웹서버에게 데이터를 전달할 수 있다. 내가 읽고싶은 정보는 html 이고,  12page로 갈것이다. 등을 전달할 수 있다. 무조건 ?으로 시작하기로 약속이 되어있다. 그리고 값과 값은 &amp;을 지정하기로 되어있다. 값의 이름과 값은 =으로 하기로 약속이 되어있다.\n\nnodejs url parse query string\nconst url = require(&#039;url&#039;);\n\nnode js가 가지고있는 수많은 기능들을 비슷한 기능으로 그룹핑한것⇒모듈\n나 지금부터 url모듈을 사용할거야. url이라는 변수를 이용해서말이야.\nconst queryData = url.parse(_url, true).query;\n\nqueryData의값이 객체로 넘어온다.   { id: html }이런식으로말이다.\nconsole.log(queryData.id)\n\n이렇게 하면 정확하게 내용이 넘어오게 되는 것이다.\nresponse.end(queryData.id);\n\n위와같이 치면 화면에 해당 아이디가 나오는 위대한 결과를 맞이할 수 있다! Wow!\n이렇게 우리는 사용자가 넘긴 데이터를 자그마치 객체로 가져와서 내가 원하는 값만 뽑아내는 일을 진행했다."},"Node-js/3.-동적-페이지-구성하기":{"slug":"Node-js/3.-동적-페이지-구성하기","filePath":"Node js/3. 동적 페이지 구성하기.md","title":"3. 동적 페이지 구성하기","links":[],"tags":[],"content":"\ntemplate라는 변수에 html전문을 넣고 한번 직관적으로 작성해보자.\nhtml전문을 넣을때 중간중간 동적으로 바뀌면 좋겠다고 생각하는 내용은 ${}의 템플릿 리터럴을 이용해서 변경한다\nhtml전문 내에서 a태그는 쿼리스트링을 이용해서 갈 수 있도록 변경한다.\n그냥 queryData.id라고 하면 예쁘지않으니까 title이라는 변수를 이용해서 값을 넣어준다.\n루트로 진입시에는 라우팅 내부를 title변수는 Welcome로 변경해주는 아이로 만들면 된다.\n\n \nconst http = require(&#039;http&#039;);\nconst fs = require(&#039;fs&#039;);\nconst url = require(&#039;url&#039;); // 요구하다. require // 나 이제 url모듈을 사용할거야. \n \nconst app = http.createServer((request,response)=&gt;{\n    let _url = request.url;\n    const queryData = url.parse(_url, true).query;\n \n    let title = queryData.id;\n    // console.log(queryData.id);\n    if(_url == &#039;/&#039;){\n      title = &#039;Welcome&#039;; // 라우팅이 /으로 들어왔을때의 내용. \n    }\n    if(_url == &#039;/favicon.ico&#039;){\n      return response.writeHead(404);\n    }\n    response.writeHead(200);\n    const template = `\n      &lt;!doctype html&gt;\n      &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;WEB1 - ${title}&lt;/title&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt;&lt;a href=&quot;/&quot;&gt;WEB&lt;/a&gt;&lt;/h1&gt;\n        &lt;ol&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=HTML&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=CSS&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=JavaScript&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;h2&gt;${title}&lt;/h2&gt;\n        &lt;p&gt;&lt;a href=&quot;www.w3.org/TR/html5/&quot; target=&quot;_blank&quot; title=&quot;html5 speicification&quot;&gt;Hypertext Markup Language (HTML)&lt;/a&gt; is the standard markup language for &lt;strong&gt;creating &lt;u&gt;web&lt;/u&gt; pages&lt;/strong&gt; and web applications.Web browsers receive HTML documents from a web server or from local storage and render them into multimedia web pages. HTML describes the structure of a web page semantically and originally included cues for the appearance of the document.\n        &lt;img src=&quot;coding.jpg&quot; width=&quot;100%&quot;&gt;\n        &lt;/p&gt;&lt;p style=&quot;margin-top:45px;&quot;&gt;HTML elements are the building blocks of HTML pages. With HTML constructs, images and other objects, such as interactive forms, may be embedded into the rendered page. It provides a means to create structured documents by denoting structural semantics for text such as headings, paragraphs, lists, links, quotes and other items. HTML elements are delineated by tags, written using angle brackets.\n        &lt;/p&gt;\n      &lt;/body&gt;\n      &lt;/html&gt;\n \n    `;\n    // console.log(__dirname+_url);\n    // response.end(fs.readFileSync(__dirname + _url));\n    response.end(template);\n \n});\napp.listen(3000);\n \n "},"Node-js/4.-file-Read":{"slug":"Node-js/4.-file-Read","filePath":"Node js/4. file Read.md","title":"4. file Read","links":[],"tags":[],"content":"nodejs file read\n현재는 타이틀은 변경이 되지만, 실제 웹페이지의 본문은 변경이 되지 않는 것을 볼 수 있다.\n이를 해결하기 위해 우리는 파일을 만들어 본문들을 관리하고, 쿼리스트링으로 요청이 들어왔을때 해당 내용에 맞는 본문을 출력해주는 시스템을 갖추면 되는 것이다.\n자, 그러면 지금부터 nodejs에서 어떻게 파일을 읽는가를 알아보자.\n위 제목처럼 nodejs file read라고 구글검색을 진행하면 공식사이트가 나온다.\nnodejs.org/api/fs.html\n공식사이트에서 수많은 모듈(nodejs에서  기본적으로 제공하는 기능들을 그룹으로 정리해둔 것)이 나온다\n여기서 참고해서 앞으로도 노드js에서 제공하는 모듈들을 사용할 수 있다\n이름안에 많은것들이 암시되어있으므로 예제를 한번 보면서 사용법을 알아내자.\n앞으로도 나는 계속 공부를 해야할 테니까말이다.\n\n파일을 다룰 때에는 파일시스템을 사용해야한다.\n\nconst fs = require(&#039;fs&#039;);\n\n이제는 파일시스템을 사용할수 있기때문에 정해진 방식대로 fs를 사용한다\n\nfs.readFile(&#039;sample.txt&#039;,(err,data)=&gt;{\n\tconsole.log(data);\n})\n\n이렇게 하고 서버를 실행해볼까?\n참고로 현재 파일시스템의 구조는 다음과 같다.\n프로젝트 폴더 &gt; nodejs &gt; fileread.js\n프로젝트 폴더 &gt; nodejs &gt; sample.txt\n이런 상태에서 이제 서버를 실행하고자 이렇게 입력했다\n\nnode nodejs/readfile \n\n\n그런데 아무 글도 읽을수가 없는거야.  undefined래. 왜일까?\n자, 생각해봐. 우리가 지금 노드를 실행시키는 폴더는 프로젝트 폴더야.\n여기서 생각했을 때 sample.txt 는 현재 폴더에 없으므로 찾을수가 없는거지.\n그래서 저 아이를 불러오려면 여기서 노드를 실행시키는 것이 아니라 nodejs폴더로 진입해서\n그 안에서 노드를실행시켜야 하더라.\n\nnode readfile\n\n\n오, 이제 나오기는 하는데 이진방식으로 나오는거야.\n\n&lt;Buffer eb 8f 99 ed 95 b4 eb ac bc ea b3 bc 20 eb b0 b1 eb 91 90 ec 82 b0 ec 9d b4 20 eb a7 88 eb a5 b4 ea b3 a0 20 eb 8b b3 eb 8f 84 eb a1 9d 20 ed 95 98 eb ... 295 more bytes&gt;\n\n\n알아 볼 수가 없는 내용이라서 우리가 알아볼 수 있게 utf-8방식으로 나오게 세팅했어\n\nconst fs = require(&quot;fs&quot;); // 파일시스템을 이제 다룰 수 있음\n \nfs.readFile(&#039;sample.txt&#039;, &#039;utf-8&#039;, (err, data)=&gt;{\n    console.log(data);\n});"},"Node-js/5.-파일로-분리한-본문-로드하기":{"slug":"Node-js/5.-파일로-분리한-본문-로드하기","filePath":"Node js/5. 파일로 분리한 본문 로드하기.md","title":"5. 파일로 분리한 본문 로드하기","links":[],"tags":[],"content":"\n\ndata라는 폴더에 각각의 본문을 넣어둔다 (확장자명은 필요없으나 파일명은 쿼리스트링으로 넘어올 값으로 지정한다)\n\n\nmain.js에서 변수로 해당내용을 치환하는 진짜 작업을 해보자\n\n\nfs.readFile()으로 값을 가지고 올것이다.\n\n\n fs.readFile(`data/${queryData.id}`,&#039;utf-8&#039;, (err, discription)=&gt;{\n \n      const template = `\n      &lt;!doctype html&gt;\n      &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;WEB1 - ${title}&lt;/title&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt;&lt;a href=&quot;/&quot;&gt;WEB&lt;/a&gt;&lt;/h1&gt;\n        &lt;ol&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=HTML&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=CSS&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=JavaScript&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;h2&gt;${title}&lt;/h2&gt;\n        &lt;p&gt;${discription}&lt;/p&gt;\n      &lt;/body&gt;\n      &lt;/html&gt;\n \n      `;\n      response.end(template);\n    })\n\n위처럼  readFile로 가져온 내용을 넣어준다. template파일이나 end도 넣어준다.\n이제는 node 를 실행하고나서, 중간에 HTML파일이나 CSS파일을 수정한다면 바로바로 반영이된다. 왜냐? 요청이 올때마다 내 컴퓨터의 파일을 하나하나 읽어서 실시간으로 보여주는 것이거든\n"},"Node-js/6.-readdir":{"slug":"Node-js/6.-readdir","filePath":"Node js/6. readdir.md","title":"6. readdir","links":[],"tags":[],"content":"파일의 목록을 읽는 readdir공부하자\nconst testFolder = &#039;./data&#039;;\nconst fs = require(&#039;fs&#039;);\n \nfs.readdir(testFolder, (err, filelist)=&gt;{\n\tconsole.log(filelist);\n})\n여기서 testFolder의 경로는  node를 실행하는 그 위치를 기준으로 한다.\n따라서 지금 위 코드는  (프로젝트 폴더 &gt; nodejs)폴더 내에 있는 readdir.js파일이지만\n실제 node는 프로젝트 폴더단에서 실행하기때문에 해당 위치는 노드가 실행되는 위치를 기준으로 한다\ndata폴더는 (프로젝트폴더 &gt; data) 의 형태로 되어있어도 찾을 수가 있다는 말이다.\n만약에 쟤를 찾아들어가는거라면 ../data이렇게 적었겠지만 노드가 실행되는 위치를 기준으로 한다!!\n저 위에있는 코드를 실행시킨다면, data안에있는 파일의 목록을 배열로 출력해준다.\n\n여기까지 파일을 읽는법, 파일 목록을 읽는법을 공부했다.\n그래서 내가 할 수 있었던 일은 특정폴더에 파일이 추가됨에 따라 해당 목록을 리스트로 보여주고,\n그 내용으로 진입해서 보여줄 수 있게 해줄 수 있다.\n하나의 /라는 진입경로로 ?id라는 쿼리스트링을 이용해서 여러가지 페이지를 보여줄 수 있었고\n뿐만아니라 컴퓨터에 파일을 추가하면 알아서 새 목록으로 읽어낼 수 있게 만들어주는\n놀라운 결과를 경험한 것이다."},"Node-js/7.-synchronous--and--asynchronous":{"slug":"Node-js/7.-synchronous--and--asynchronous","filePath":"Node js/7. synchronous & asynchronous.md","title":"7. synchronous & asynchronous","links":[],"tags":[],"content":"동기와 비동기.\nnodejs는 비동기 처리를 하기위한 좋은 기능들을 많이 가지고있다\n예를 들어서 알아보자. readFile을 이용해서 파일읽기를 한번 진행해볼것이다\nreadFileSync\n그야말로 동기적인 방식으로 파일읽기를 실행한다\nconst fs = require(&#039;fs&#039;);\n \nconsole.log(&#039;A&#039;);\nconst result = fs.readFileSync(&#039;/syntax/sample.txt&#039;, &#039;utf8&#039;);\nconsole.log(result);\nconsole.log(&#039;C&#039;);\n \n위와같이 적어주면 순서대로 실행이된다.\nA\nB ( sample.txt에는 B라는 글자가 있다 )\nC\n\nreadFile\n반면에 노드에서 더 추천하기때문에 기본값으로 설정해둔 readFile을 이용해서 비동기방식으로 진행해볼까?\nconst fs = require(&#039;fs&#039;);\n \nconsole.log(&#039;A&#039;);\nfs.readFile(&#039;/syntax/sample.txt&#039;,&#039;utf8&#039;,(err, data)=&gt;{\n\tconsole.log(data);\n});\nconsole.log(&#039;C&#039;);\n리턴값을 주는 readFileSync와는 달리 readFile은 파일을 읽고 다 읽은 내용을 함수안에 넣어준다.\n위와 같이 코드를 작성하고 실행하면 그 결과는\nA\nC\nB (sample.txt의 내용)\n이와같은 형태로 나온다.\n비동기이기때문에 결과값을 가져오기전에 이미 C 를 찍어버린다는 특징이 있다\n바로 이것이 비동기방식이다.\n다 하고 나서 나중에 전화해 - 콜백"},"Node-js/8.-PM2":{"slug":"Node-js/8.-PM2","filePath":"Node js/8. PM2.md","title":"8. PM2","links":[],"tags":[],"content":"서버가 꺼지면 다시 실행시켜주는 기능도 하고있고,\n파일이 수정되는지 관찰하고있다가 수정되었으면 자동으로 껐다켜주는 기능도 하고있다\n설치\nsudo npm install pm2 -g\n\n실행\npm2 start main --watch\n\n\nwatch기능을 넣어서 파일수정시 자동으로 서버를 재시동하도록 설정할 수 있다\n\n현재 pm2로 실행하고있는 프로그램 보기\npm2 monit\n\n현재 실행중인 프로세스 확인\npm2 list\n\n로그보기(에러확인)\npm2 log\n\n종료\npm2 stop main\n"},"Node-js/9.-Post-Data-객체화하기":{"slug":"Node-js/9.-Post-Data-객체화하기","filePath":"Node js/9. Post Data 객체화하기.md","title":"9. Post Data 객체화하기","links":[],"tags":[],"content":"form을 통해서 전송된 데이터를 받아오고, 객체화 해보자\n\n\npathname이 /create_process 로 들어왔을때를 작성하기위해 http.createServer메서드 내부에 라우팅을 추가하자.\n\n\nnodejs post data라고 구글에 검색해서 확인해보자.\n\n\nbody라는 빈 변수를 하나 만들어준다\n\n\nrequest에 붙어 나오는 data를 on이라는 메서드 안에서 받아와준다.\n\n\nrequest.on(&#039;data&#039;, (data)=&gt;{\n        //엄청 많이 들어올 것을 대비해서 조각조각 정보를 담는다.\n        body += data;\n  });\n\n모두 받아서 더이상 받을게 없을 때에 post라는 변수에다가 내용을 모두 담는다. 이때는 그냥 담는 것이 아니라 parse라는 메서드를 사용하는데, 이 내용은 위쪽에 require(‘querystring’)으로 불러와서 사용한다.\n\n  request.on(&#039;end&#039;,()=&gt;{\n\t//더이상 들어올 정보가 없다면,\n\tconst post = qs.parse(body); //모든 정보 객체화.\n\tconsole.log(post);\n\tconst bodyTitle = post.title;\n\tconst bodyDescription = post.description;\n  });"},"Node-js/Generator":{"slug":"Node-js/Generator","filePath":"Node js/Generator.md","title":"Generator","links":[],"tags":[],"content":"이터러블을 생성하는 함수.\n제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 좀 더 간편하게 이터러블을 구현할 수 있고, 비동기 처리에 유용하게 사용된다.\n// 무한 이터러블을 생성하는 제너레이터 함수\nfunction* createInfinityByGenerator() {\n  let i = 0;\n  while (true) { yield ++i; }\n}\n \nfor (const n of createInfinityByGenerator()) {\n  if (n &gt; 5) break;\n  console.log(n); // 1 2 3 4 5\n}\nfunction*\nfunction* 는 제너레이터 함수를 정의하기 위한 JavaScript의 특별한 문법.\n제너레이터 함수는 일반 함수와 달리 실행을 중간에 멈추고, 필요할 때 다시 재개할 수 있는 기능을 제공한다\n이를 통해 값을 하나씩 반환하거나, 반복 가능한 데이터를 생성하는 데 유용하다.\nyield\nyield는 JavaScript에서 제너레이터 함수(function*) 안에서 사용되는 키워드로, 함수의 실행을 일시 중지하거나 재개할 수 있게 한다. 얘 덕분에 제너레이터 함수는 값을 하나씩 생성하며 호출자에게 반환할 수 있다.\nfunction* counter(){\n    console.log(&#039;round1&#039;);\n    yield 1;\n    console.log(&#039;round2&#039;);\n    yield 2;\n    console.log(&#039;round3&#039;);\n}\n \nconst generatorObj = counter();\n \nconsole.log(generatorObj.next());\nconsole.log(generatorObj.next());\nconsole.log(generatorObj.next());\nconsole.log(generatorObj.next());\n위 코드를 화살표함수로는 쓸 수 없는지 궁금했어.\n그래서 찾아보니까 제너레이터는 화살표함수로 쓸 수가 없어\n그리고 counter().next()로 바로 쓸수도있지만, 그렇게하면 두번째 yield를 가져올 수가없어.\n그러니까 한데 담아서 가져오는게 맞지.\n충격적인 GENERATOR\nfunction* counter(){\n    for(const v of [1,2,3]) {\n        yield v;\n    }\n}\nlet generatorObj = counter();\nconsole.log(Symbol.iterator in generatorObj);\nfor(const i of generatorObj){\n    console.log(&#039;Obj:&#039; + i);\n}\n \n// 놀랍게도 이것도 성립한다✅✅✅✅✅✅✅\nfunction* counter2(){\n    yield* [1,2,3];\n}\n \nlet generatorObj2 = counter2();\nfor(const i of generatorObj2){\n    console.log(&#039;Obj2:&#039; + i);\n}\n \n \ngeneratorObj = counter();\n \nconsole.log(&#039;next&#039; in generatorObj);\n \nconsole.log(generatorObj.next());\nconsole.log(generatorObj.next());\nconsole.log(generatorObj.next());\nconsole.log(generatorObj.next());\nyield*? 이게 성립한다고?\nfunction* counter2(){\n\tyield* [1,2,3];\n}\nOK! 물론 성립하지. yield*은 현재 제네레이터의 실행을 다른 이터러블이나 제네레이터에게 위임한다는 뜻이야. yield* 의 뒤에 오는 이터러블 객체의 모든 값을 순회할 것이고. 각각의 값을 하나씩 현재 제네레이터의 yield지점으로 전달할 수 있다는 거거든.\n크게 두개의 의미를 갖는다고 할 수 있겠네.\n\n위임: 내 뒤에 오는 어떤놈의 요소를 모두 순회하여 하나씩 뽑아오겠다 - 이터러블이 와야대\n반복: 내부적으로 이터러블 객체를 순회하며 그 값을 하나씩 반환한대.  for…of처럼 말이야.\n\n제네레이터 함수 정의\nfunction* genDecFunc(){\n\tyield 1;\n}\n \nlet generatorObj = genDecFunc();\nconst genExpFunc = function* () {\n\tyield 1;\n};\ngeneratorObj = genExpFunc();\n \nconst obj = {\n\t* generatorObjMethod(){\n\t\tyield 1; \n\t}\n}\n \ngeneratorObj = obj.generatorObjMethod();\n \nclass MyClass {\n\t* generatorClsMethod(){\n\t\tyield 1;\n\t}\n}\n \nconst myClass = new MyClass();\ngeneratorObj = myClass.generatorClsMethod();\n()⇒{} 이 형태는 적을 수 가 없다\n그 내부에서 this를 쓸 수도 없고 별 기도호 못쓰니까.\n이터러블을 제네레이터로 바꿔서 볼까?\nconst infiniteFibonacci = ( function*(){\n    let [pre, cur] = [0,1];\n \n    while (true){\n        [pre, cur] = [cur, pre+cur];\n        yield cur;\n    }\n}() );\n \nfor(const num of infiniteFibonacci){\n    if(num&gt;10000) break;\n    console.log(num);\n}\n \nconsole.log(&#039;***********&#039;);\n \nconst createInfiniteFibByGen = function* (max) {\n    let [prev, curr] = [0,1];\n \n    while (true) {\n        [prev, curr] = [curr, prev+curr];\n        if(curr&gt;= max) return; // 오 그래?? 그럼 이제 끝내!!!\n        yield curr; // 끝내지는말고 일단이거 리턴하고 정지 (다음에 부르면 다음꺼나감)\n    }\n};\n \nfor(const num of createInfiniteFibByGen(30000)){\n    console.log(num);\n}"},"Node-js/JS의-배열고차함수":{"slug":"Node-js/JS의-배열고차함수","filePath":"Node js/JS의 배열고차함수.md","title":"JS의 배열고차함수","links":[],"tags":[],"content":"sort\nsort는 배열의 요소를 적절하게 정렬한다.\n오름차순이나 내림차순으로 정렬할 수 있다.\n원본파괴하여 직접 배열을 건드린다.\nconst fruits = [&#039;Banana&#039;, &#039;Orange&#039;, &#039;Apple&#039;];\n \n// ascending(오름차순)\nfruits.sort();\nconsole.log(fruits); // [ &#039;Apple&#039;, &#039;Banana&#039;, &#039;Orange&#039; ]\n \n// descending(내림차순)\nfruits.reverse();\nconsole.log(fruits); // [ &#039;Orange&#039;, &#039;Banana&#039;, &#039;Apple&#039; ]\n오름차순이나 내림차순으로 정렬한다고 했지만, 이는 문자열 정렬이기때문에 유니코드 순서대로다.\n숫자를 정렬할때는 다른 방식을 사용해야한다.\nconst points = [40, 100, 1, 5, 2, 25, 10];\n \n// 숫자 배열 오름차순 정렬\n// 비교 함수의 반환값이 0보다 작은 경우, a를 우선하여 정렬한다.\npoints.sort(function (a, b) { return a - b; });\nconsole.log(points); // [ 1, 2, 5, 10, 25, 40, 100 ]\n \n// 숫자 배열 내림차순 정렬\n// 비교 함수의 반환값이 0보다 큰 경우, b를 우선하여 정렬한다.\npoints.sort(function (a, b) { return b - a; });\nconsole.log(points); // [ 100, 40, 25, 10, 5, 2, 1 ]\n \nforEach\n가장 기본이 되는 배열 고차함수로 for문 대신 사용할 수 있다.\n배열 순회하면서 콜백함수를 실행한다.\n원본은 건드리지않는다\n매개변수로는  value, index, array를 받는다.\nfor문과는 달리 break를 사용하지않는다. - 순회 중단이 불가하다\nfor문보다 성능이 좋은 것은 아니지만 가독성이 좋다.\nnumbers.forEach(function (item, index, self) {\n  console.log(`numbers[${index}] = ${item}`);\n  total += item;\n});\nmap\n배열 순회하는 것은 똑같으나 리턴해서 새로운 배열을 완성해낸다. 원본 배열을 하지않는다\n즉, 다른 값으로 매핑하기 위한 함수라고 보면 된다. (한바퀴 쭉 돌려서 배열을 만들어내고싶을때)\nv, i, a를 받는다는 점에서 똑같다.\nconst numbers = [1, 4, 9];\n \nconst roots = numbers.map(function (item) {\n  return Math.sqrt(item);\n});\n \n// 위 코드의 축약표현은 아래와 같다.\n// const roots = numbers.map(Math.sqrt);\n \nconsole.log(roots);   // [ 1, 2, 3 ]\nconsole.log(numbers); // [ 1, 4, 9 ]\nfilter\n배열을 만들어낸다는 점에서  map과 비슷하지만 filter는  if문을 대체할 수 있다.\n배열을 순회하며 각 요소에 대하여 인자로 주어진 콜백함수가 “참”인 결과만을 뽑아내서 배열을 반환한다.\nconst result = [1, 2, 3, 4, 5].filter(function (item, index, self) {\n  console.log(`[${index}] = ${item}`);\n  return item % 2; // 홀수만을 필터링한다 (1은 true로 평가된다)\n});\n \nconsole.log(result); // [ 1, 3, 5 ]\nreduce\n배열을 순회하며 각 요소에 대하여 이전의 콜백함수 실행 반환값을 전달하여 콜백함수를 실행하고 그 결과를 반환한다.\nconst arr = [1, 2, 3, 4, 5];\nconst sum = arr.reduce(function (previousValue, currentValue, currentIndex, self) {\n  console.log(previousValue + &#039;+&#039; + currentValue + &#039;=&#039; + (previousValue + currentValue));\n  return previousValue + currentValue; // 결과는 다음 콜백의 첫번째 인자로 전달된다\n});\nsome\n배열 안에있는 요소가 콜백함수의 테스트를 통과하는지 확인해서 그 결과값을 boolean으로 반환한다.\n하나라도 통과하면 true를 반환한다.\n// 배열 내 요소 중 10보다 큰 값이 1개 이상 존재하는지 확인\nlet res = [2, 5, 8, 1, 4].some(function (item) {\n  return item &gt; 10;\n});\nconsole.log(res); // false\n \nres = [12, 5, 8, 1, 4].some(function (item) {\n  return item &gt; 10;\n});\nconsole.log(res); // true\n \n// 배열 내 요소 중 특정 값이 1개 이상 존재하는지 확인\nres = [&#039;apple&#039;, &#039;banana&#039;, &#039;mango&#039;].some(function (item) {\n  return item === &#039;banana&#039;;\n});\nconsole.log(res); // true\nevery\nsome 과 비슷한데 이번에는 모든 아이들이 다 통과해야한다.\n// 배열 내 모든 요소가 10보다 큰 값인지 확인\nlet res = [21, 15, 89, 1, 44].every(function (item) {\n  return item &gt; 10;\n});\nconsole.log(res); // false\n \nres = [21, 15, 89, 100, 44].every(function (item) {\n  return item &gt; 10;\n});\nconsole.log(res); // true\nfind\n배열을 순회하면서 각 요소에 대해 인자로 주어진 콜백함수를 실행하고,\n그 결과가 참인 첫번째 요소를 반환한다.\n혹시라도 참인것을 발견하지 못했을 때에는 undefined를 반환한다.\nv, i, a를 가져갈 수 있다.\nfilter와 비슷하지만, filter는 언제나 배열을 추출하는 반면에 find는 콜백함수를 실행하여 그 결과가 참인 첫번째 결과값을 반환하므로 결과값이 언제나 일반 요소값이다.\nconst users = [\n  { id: 1, name: &#039;Lee&#039; },\n  { id: 2, name: &#039;Kim&#039; },\n  { id: 2, name: &#039;Choi&#039; },\n  { id: 3, name: &#039;Park&#039; }\n];\n \n// 콜백함수를 실행하여 그 결과가 참인 첫번째 요소를 반환한다.\nlet result = users.find(function (item) {\n  return item.id === 2;\n});\n \n// ES6\n// const result = users.find(item =&gt; item.id === 2;);\n \n// Array#find는 배열이 아니라 요소를 반환한다.\nconsole.log(result); // { id: 2, name: &#039;Kim&#039; }\n \n// Array#filter는 콜백함수의 실행 결과가 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다.\nresult = users.filter(function (item) {\n  return item.id === 2;\n});\n \nconsole.log(result); // [ { id: 2, name: &#039;Kim&#039; },{ id: 2, name: &#039;Choi&#039; } ]\nfindIndex\n마지막으로 알아볼 배열고차함수!!!\nv,i,a를 받을 수 있고, 배열 순회하면서 콜백함수 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다.\n콜백함수의 실행 결과가 참인 요소가 존재하지 않으면 -1을 반환한다.\nconst users = [\n  { id: 1, name: &#039;Lee&#039; },\n  { id: 2, name: &#039;Kim&#039; },\n  { id: 2, name: &#039;Choi&#039; },\n  { id: 3, name: &#039;Park&#039; }\n];\n \n// 콜백함수를 실행하여 그 결과가 참인 첫번째 요소의 인덱스를 반환한다.\nfunction predicate(key, value) {\n  return function (item) {\n    return item[key] === value;\n  };\n}\n \n// id가 2인 요소의 인덱스\nlet index = users.findIndex(predicate(&#039;id&#039;, 2));\nconsole.log(index); // 1\n \n// name이 &#039;Park&#039;인 요소의 인덱스\nindex = users.findIndex(predicate(&#039;name&#039;, &#039;Park&#039;));\nconsole.log(index); // 3"},"Node-js/Map":{"slug":"Node-js/Map","filePath":"Node js/Map.md","title":"Map","links":["Node-js/Set"],"tags":[],"content":"특정심볼이 특정한 값을 가지고 있을 때 사용한다.\n값을 key-value 묶음으로 표현한 객체\n기존의 객체와 비슷하지만, 키로 어떤 데이터 타입이든 사용할 수 있다.\n고유한 값의 집합을 효율적으로 관리할 수 있다\n뭐가 좋아?\n\n키의 다양성이 높아진다 - 모든 데이터 타입이 가능하다\n순서보장 - 이터러블이다\n크기확인 - size프로퍼티를 사용하면 map에 저장된 요소의 개수를 확인할수 있다\n메서드제공: 데이터를 추가/삭제/검색할 수 있는 메서드를 지원한다\n\n어떻게 만들지?\nconst map = new Map([[&#039;key1&#039;, &#039;value1&#039;], [&#039;key2&#039;, &#039;value2&#039;]]);\n값을 추가할 수 있나?\nmap.set(&#039;key3&#039;, &#039;value3&#039;);\n위와같이 업데이트 할 수 있다\n만들어진 값은 어떻게 가져와?\nconsole.log(map.get(&#039;key1&#039;)); // &#039;value1&#039;\n종합 예제\nconst map = new Map();\nmap.set(&#039;name&#039;, &#039;Alice&#039;);\nmap.set(&#039;age&#039;, 25);\nconsole.log(map.get(&#039;name&#039;)); // Alice\nconsole.log(map.has(&#039;age&#039;)); // true. -- 가지고있니?\nmap.delete(&#039;age&#039;);  // -- 이걸 지우겠다\nconsole.log(map.size); // 1  (현재 사이즈는?)\nset이랑 같이 많이 묶어서 공부하던데, 한번 비교해볼까?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n특징MapSet데이터 구조키-값(Key-Value) 쌍고유한 값(Value)키 타입모든 데이터 타입 가능없음 (값만 저장)중복 허용 여부키는 중복 불가, 값은 중복 가능중복된 값 허용하지 않음삽입 순서 유지유지유지주요 사용 사례데이터 매핑, 객체 대체중복 제거, 유일한 값 관리\nSet"},"Node-js/Node-핵심-개념":{"slug":"Node-js/Node-핵심-개념","filePath":"Node js/Node 핵심 개념.md","title":"Node 핵심 개념","links":[],"tags":[],"content":"Node js가 무엇일까?\nNode.js은 Chrome V8 Javascript엔진으로 빌드된 자바스크립트 런타임입니다.\n런타임이란\n특정 언어로 만든 프로그램들을 실행할 수 있는 환경\n즉, Node js는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해준다.\n다시 말해서 자바스크립트 실행기라고 할 수 있는 셈이다.\n그동안에는 브라우저가 자바스크립트 런타임을 내장하고 있으므로 자바스크립트 코드를 실행할 수 있었지만 일반 컴퓨터에서는 런타임이 없어 실행할 수가 없었다. 그래서 나온게 바로 Node js라는 소리다.\n\nNode js의 주요한 특징\n이벤트 기반\n이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 말한다.\n클릭이나 네트워크 요청 등을 우리는 이벤트가 일어났다고 부르는데, 이러한 이벤트 기반 시스템에서는 특정 이벤트가 발생할때 대체 뭘 해야하는 것인지 미리 등록을 해야한다.\n이것을 우리는 이벤트 리스너 또는, 콜백함수를 등록한다고 한다.\n즉, 노드는 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백함수를 호출해서 진행한다.\n발생한 이벤트가 없거나 발생했던 이벤트를 다 처리해버린다면 Node는 다음 이벤트가 발생할때까지 대기하고있다.\nNode js는 자바스크립트 코드의 맨 윗줄부터 한줄씩 실행하다가 함수 호출을 만나면 호출한 함수를 호출 스택(Call Stack)에 담는다.\nCall Stack\n호출스택은 함수가 호출되었을때 담아놓는 스택구조의 상자다. 일단은 맨 처음에 anonymous라는 최초 실행시의 global context이다. 얘는 무조건 함수호출시 가장먼저 생성되는 환경이므로, 그냥 기본적으로 자바스크립트 코드 실행시에는 이 global context 안에서 돌아간다고 봐도 무방하다. 함수들이실행되는 동안 global context는 call stack안에 있다가 실행이 완료되면 지워진다.\nEvent Loop\n이벤트 발생시에 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수들의 실행 순서를 결정한다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 계속 반복하니까 루프라는 표현을 쓴다.\nBackground\nsetTimeout과 같은 타이머나 이벤트 리스너들이 대기하는 곳이다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 무방하다. 여기선 여러작업이 동시에 실행가능하다.\nTask queue\n이벤트 발생 후, 백그라운드에서는 태스크 큐로 타이머나 이벤트리스너의 콜백함수를 보낸다 정해진 순서대로 콜백들이 줄을 서있으므로 콜백 큐라고도 한다. 콜백들은 보통 완료된 순서대로 줄을 서있지만 특정한 경우 순서가 바뀌기도 한다.\nNon-blocking I/O\n우선은 블로킹과 논블로킹의 차이부터 알아야한다.\n\n블로킹 - 이전 작업이 끝나야만 다음 작업을 수행한다\n논블로킹 - 이전 작업이 완료되던가말던가 그다음작업이 실행된다\n\nNode js에서는 파일의 입력 출력(I/O라고 부른다)을 할 때, 즉, 파일 시스템 접근이나 네트워크를 통한 요청 같은 작업을 할 때 논블로킹방식을 택한다. 논블로킹 방식은 블로킹방식보다 더 짧은 시간에 처리할 수 있다는 장점이 있다. 다만!! 작업들이 모두 동시에 처리될 수 있는 작업이라는 전제가 있어야한다.\nNode js에서는 I/O 작업을 위에서 배운 백그라운드에 넘겨서 동시에 처리한다. 동시에 처리될 수 있는 작업들을 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다.\n싱글 스레드\n그 유명한 싱글스레드는 스레드가 하나 뿐이라는 의미다.\n내가 만든 자바스크립트 코드가 동시에 실행될 수 없다는 것도 스레드가 하나뿐이기때문이다.\n먼저, 잠시 프로세스와 스레드의 차이를 한번 알아보자\n\n프로세스 - 운영체제에서 할당하는 작업의 단위다. 노드나 브라우저같은 프로그램은 개별적인 별도의 프로세스들이다. 이런 프로세스간에는 메모리등의 자원을 공유하지않는다.\n스레드 - 프로세스 내에서 실행되는 흐름의 단위이다. 프로세스는 스레드를 여러개 생성해서 여러작업을 동시에 처리할 수 있다. 같은 스레드끼리는 자기들을 묶어주는 부모 프로세스의 자원을 공유할 수 있다.\n\n노드는 원래 실행 후 프로세스 하나 만들고 여기에 스레드들을 생성하는데, 내부적으로 여러개를 생성하기는 하나 내가 직접 건드릴 수 있는 스레드는 오직 하나 뿐이다. 그래서 싱글스레드라고 할 수 있는 것이다.\n\n점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤에 다음 손님의 주문을 받는다. 요리가 끝나기까지 기다리는 대신 주문이 들어왔다는 것만 주방에 계속해서 알려주는 것이다. 주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙한다. 요리가 오래걸리는건 좀 늦게 나올 수도 있다. (블로킹인지 논블로킹인지에 따라 완료되는 순서가 다를 수 있다).\n\n바로 위 내용이 싱글 스레드, 즉 논블로킹 모델이다.\n\n노드를 서버로 쓰면 무엇이 좋은가?\n\n서버에는 I/O 요청이 많이 발생하는데, 노드는 이를 논블로킹 처리하기때문에 스레드 하나가 많은 수의 I/O를 혼자서 감당한다.\n개수는 많지만 크기는 작은 데이터를 실시간으로 주고받을 때 최적화 되어있다\n멀티스레드보다 프로그래밍이 상대적으로 쉽다\n웹서버가 내장되어있어서 nginx같은걸 따로 설치할 필요가없다\n"},"Node-js/Promiss":{"slug":"Node-js/Promiss","filePath":"Node js/Promiss.md","title":"Promiss","links":["Node-js/json()-메서드"],"tags":[],"content":"비동기에서 콜백지옥에서 벗어나기위해 사용하는 객체로, 실행은 하지만 결과값은 나중에 받도록 설정하는 객체를 말한다.\npromise라는 것 자체가 비동기 함수가 반환하는 객체라고 할 수 있다\npromise\n\t.then((msg1)=&gt;{\n\t\treturn new Promise((resolve, reject)=&gt;{\n\t\t\tresolve(msg1);\n\t\t});\n\t})\n\t.then((msg2)=&gt;{\n\t\treturn new Promise((resolve, reject)=&gt;{\n\t\t\tresolve(msg2);\n\t\t});\n\t})\n\t.then((msg3)=&gt;{\n\t\tconsole.log(msg3);\n\t})\n\t.catch((err)=&gt;{\n\t\tconsole.log(err);\n\t})\n위와같은 형식으로 이용할 수 있다.\n비동기가 기본인 자바스크립트에서 동기처럼 사용하고 싶어서 쓰는 객체라고 생각하면된다.\n일단 실행을하고, 결과값은 실행이 완료된 후에 then이나 catch에서 받는다.\nthen이 수행이 되면 값은 다음의  then으로 이어지고 혹시라도 중간에 오류가 나타나면 catch가 수행된다고 볼 수 있다.\n\n비동기 작업을 처리하기위한 객체인데,\n작업의 성공이나 실패를 나타내며 비동기코드를 보다 동기처럼 체계적으로 관리할 수 있다\nconst myPromise = new Promise((resolve, reject) =&gt; {\n  // 비동기 작업 수행\n  const data = fetch(&#039;서버로부터 요청할 URL&#039;);\n  \n  if (data) {\n    resolve(data); // 작업 성공 시 호출\n  } else {\n    reject(&quot;Error&quot;); // 작업 실패 시 호출\n  }\n});\n \n보통 promise는 보통 이렇게 두개의 매개변수를 받는다. resolve와 reject말이다.\nthen()은 성공했을때 실행할 것\ncatch()는 실패했을때 실행할 것\nfinally()는 성공여부와 상관없이 항상 실행되는 것이라고 볼 수 있다.\nmyPromise\n  .then(result =&gt; console.log(&quot;Success:&quot;, result))\n  .catch(error =&gt; console.error(&quot;Error:&quot;, error))\n  .finally(() =&gt; console.log(&quot;Completed&quot;));\n \npromise의 장점\n\n가독성이 매우 좋다\nthen()을 통해 체이닝으로 순차적 처리가 가능하다. 따라서 복잡한 비동기 로직을 간결하게 구현할 수 있다.\n에러를 한곳에 모아서 처리할 수 있다   (콜백형태로 하면 에러처리가 불가능하다)\npromise.all()을 이용하면 비동기 작업을 병렬로 진행할 수 있다\n특정 상황에서 비동기 작업을 취소할 수 있다\n\npromise의 단점\n\n에러처리가 너무 복잡하다\nfail-fast동작(  promise.all()은 전달된 promise 중에서 하나라도 실패하면 전체실패로 생각한다)\n\n\nBlocking model = Synchronous processing model\nnon-blocking model = Asynchronous processing model\n// Promise 객체의 생성 \nconst promise = new Promise((resolve, reject) =&gt; { // 비동기 작업을 수행한다. \n\tif (/* 비동기 작업 수행 성공 */) { \n\t\tresolve(&#039;result&#039;); \n\t} else { /* 비동기 작업 수행 실패 */ \n\t\treject(&#039;failure reason&#039;); \n\t} \n});\n위가 promise 객체의 모습이다\npromise의 상태\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n상태의미구현pending비동기 처리가 아직 수행되지 않은 상태resolve 또는 reject 함수가 아직 호출되지 않은 상태fulfilled비동기 처리가 수행된 상태 (성공)resolve 함수가 호출된 상태rejected비동기 처리가 수행된 상태 (실패)reject 함수가 호출된 상태settled비동기 처리가 수행된 상태 (성공 또는 실패)resolve 또는 reject 함수가 호출된 상태\npromise는 위와같은 상태를 가질 수 있다. 대기/성공/실패/성공또는실패 이라고 볼 수 있다\npromise 예제\nconst promiseAjax = (method, url, payload) =&gt; {\n\treturn new Promise((resolve, reject) =&gt; {\n\t\tconst xhr = new XMLHttpRequest(); //비동기 객체 만들기\n\t\txhr.open(method, url);\n\t\txhr.setRequestHeader(&#039;Content-type&#039;, &#039;application/json&#039;); //json 날릴때 json이라고 규정해주기\n\t\txhr.send(JSON.stringify(payload)); // payload가 제이슨이겠지.\n \n\t\txhr.onreadystatechange = function () {\n\t\t// 서버 응답 완료가 아니면 무시\n\t\tif (xhr.readyState !== XMLHttpRequest.DONE) return;\n \n\t\tif (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) {\n\t\t\t// resolve 메소드를 호출하면서 처리 결과를 전달\n\t\t\tresolve(xhr.response); // Success!\n\t\t} else {\n\t\t\t// reject 메소드를 호출하면서 에러 메시지를 전달\n\t\t\treject(new Error(xhr.status)); // Failed...\n\t\t}\n\t\t};\n\t});\n};\n \npromiseAjax(&#039;GET&#039;, &#039;http://localhost:4000/data&#039;, null)\n\t.then(response =&gt; {\n\t\tconsole.log(&#039;GET Success:&#039;, response);\n\t})\n\t.catch(error =&gt; {\n\t\tconsole.error(&#039;GET Error:&#039;, error);\n\t});\n\n이상하게 생긴 문법 공부하기\nresolvedPromise.then(console.log);\n \nresolvedPromise.then(res =&gt; { console.log(res); });\n공부를 하다보니, 이 두 코드가 동일하게 진행되는 것을 알 수 있었다.\n어떻게 이것이 가능할까? 알아본 결과 다음과 같다.\n첫번째 코드에서 console.log라는 이름만 전달이 되었으나, javascript는 이를 콜백으로 처리했다. promise가 완료되면 결과값이 자동으로 console.log의 첫번째 인자로 넘어가게 되는 것이다. 왜냐고? 자바스크립트의 promise시스템은 이를 자동으로 호출시점에 결과값을 인자로 전달하기 때문이다. 두번째처럼 굳이 명시하지않아도 진행이 된다. 그냥 콜백자리에 함수이름을 넣어 자동으로 인자가 쏙 들어가게 한다\n두번째 코드에서는 명시적으로 res를 받아와서 console.log(res)라고 실행했다. 이는 위와 동일하다.\n이를 다른 코드에서 확인해볼까?\nconst numbers = [1, 2, 3]; // 명시적으로 선언한 화살표 함수 \n \nnumbers.forEach(num =&gt; console.log(num)); // 동일한 동작을 하는 함수 이름 전달 방식\n \nnumbers.forEach(console.log);\n이렇게 간단하게 적을 수 있다는 것이다.\n이렇게 할 수 있는 조건은 두가지가 있는데,\n\n콜백 함수가 인자를 그대로 받아들이는 경우.\n추가 로직이 없이 그냥 이거밖에 없는 경우.\n\n두가지만 가능하다.\nPromise.all\n프로미스가 담긴 배열 등을 이터러블 인자로 전달 받는다.\n전달받은 모든 프로미스를 병렬처리하고 처리결과를 resolve하는 새로운 프로미스를 반환한다.\nall을 이용한  resolve의 순서\nPromise.all([\n\tnew Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 5000)), // 1\n\tnew Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2\n\tnew Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)) // 3\n]).then(console.log) // [ 1, 2, 3 ]\n.catch(console.log);\n위 코드를 보면 사실 비동기의 경우 3이 가장 먼저 실행되어야하지만, 그렇지 않다. 동기적으로 진행이 되기때문에 첫줄부터 시작하고 있고, 순차적으로 배열이 차곡차곡 담아서 then한테 보내는 것을 볼 수 있다.\n실패는 어떨까?\nPromise.all([\n\tnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&#039;Error 1!&#039;)), 3000)),\n\tnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&#039;Error 2!&#039;)), 2000)),\n\tnew Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&#039;Error 3!&#039;)), 1000))\n]).then(console.log)\n.catch(console.log); // Error: Error 3!\n실패는 일단 발생한놈이 우선이다. 따라서 위에코드를 보면 error1이 출력되야 정상이지만, 위 코드의 결과를 보면 가장 빠른시간내에 발생한 error3이 확인된다.\n\nPromise.race\nall이랑 비슷하게 프로미스가 담겨있는 배열을 인자로 받아서 병렬처리하지만\n순서대로 하지않고 가장 먼저 처리된 프로미스가  resolve하는 새로운 프로미스를 반환한다.\nPromise.race([\n\tnew Promise( resolve =&gt; setTimeout(()=&gt;resolve(1), 3000) ),\n\tnew Promise( resolve =&gt; setTimeout(()=&gt;resolve(2), 2000) ),\n\tnew Promise( resolve =&gt; setTimeout(()=&gt;resolve(3), 1000) )\n])\n.then(console.log)\n.catch(console.log)\n에러가 발생한 상황에서는 all과 동일하게 동작한다.  그냥 제일빨리 일어난  reject를 반환한다는 소리다.\njson() 메서드"},"Node-js/Sequelize/data-type":{"slug":"Node-js/Sequelize/data-type","filePath":"Node js/Sequelize/data type.md","title":"data type","links":[],"tags":[],"content":"Sequelize에서 사용 가능한 모든 데이터 타입을 MySQL을 기준으로 정리해보자.\n문자열 (String)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequelize 데이터 타입MySQL 자료형설명DataTypes.STRINGVARCHAR(255)기본 문자열. 길이를 지정할 수 있음.DataTypes.STRING(50)VARCHAR(50)지정된 길이의 문자열.DataTypes.STRING.BINARYVARCHAR BINARY이진 문자열.DataTypes.CHARCHAR(255)고정 길이 문자열.DataTypes.CHAR(10)CHAR(10)지정된 길이의 고정 문자열.DataTypes.TEXTTEXT긴 텍스트 데이터.DataTypes.TEXT(&#039;tiny&#039;)TINYTEXT최대 255 바이트의 작은 텍스트.DataTypes.TEXT(&#039;medium&#039;)MEDIUMTEXT최대 16MB의 중간 크기 텍스트.DataTypes.TEXT(&#039;long&#039;)LONGTEXT최대 4GB의 큰 텍스트.\n숫자 (Number)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequelize 데이터 타입MySQL 자료형설명DataTypes.INTEGERINTEGER정수형 데이터.DataTypes.INTEGER.UNSIGNEDINTEGER UNSIGNED음수가 없는 정수형.DataTypes.BIGINTBIGINT큰 정수형 데이터.DataTypes.FLOATFLOAT부동소수점 숫자.DataTypes.FLOAT(11, 10)FLOAT(11,10)소수점 이하 자릿수를 지정한 부동소수점.DataTypes.DOUBLEDOUBLE더 높은 정밀도의 부동소수점 숫자.DataTypes.DECIMAL(10, 2)DECIMAL(10,2)고정 소수점 숫자.\n날짜 및 시간 (Date and Time)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequelize 데이터 타입MySQL 자료형설명DataTypes.DATEDATETIME날짜와 시간을 포함한 데이터.DataTypes.DATE(6)DATETIME(6)최대 6자리 소수 초를 지원하는 날짜/시간.DataTypes.DATEONLYDATE날짜만 포함 (시간 없음).\n불리언 (Boolean)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequelize 데이터 타입MySQL 자료형설명DataTypes.BOOLEANTINYINT(1)참/거짓 값을 저장하는 불리언 타입.\n고유 식별자 (UUID)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequelize 데이터 타입MySQL 자료형설명DataTypes.UUIDCHAR(36)고유 식별자(UUID).\n이진 데이터 (Binary Data)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequelize 데이터 타입MySQL 자료형설명DataTypes.BLOBBLOB바이너리 데이터를 저장하는 타입.DataTypes.BLOB(&#039;tiny&#039;)TINYBLOB작은 크기의 바이너리 데이터.\n열거형 (Enum)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSequelize 데이터 타입MySQL 자료형설명DataTypes.ENUM(&#039;a&#039;, &#039;b&#039;)ENUM(&#039;a&#039;, &#039;b&#039;)지정된 값 중 하나를 선택하는 열거형 타입."},"Node-js/Set":{"slug":"Node-js/Set","filePath":"Node js/Set.md","title":"Set","links":[],"tags":[],"content":"말그대로 집합이다.\n중북되지않은 유일한 값들의 집합을 저장하는데 사용된다.\n특징이 뭐야?\n\n중복허용을 안한다 : 아무리 같은 값을 저장하려고해도 안된다!!\n순서를 보장한다 - 이터러블\n모든 데이터타입을 허용한다\n빠른조회와 삭제가 가능하다\n\n어떻게 만들어?\nconst mySet = new Set();\n중복제거를 어떻게 하지?\nconst mySet = new Set([1, 2, 3, 3, 4]);\nconsole.log(mySet); // Set { 1, 2, 3, 4 } (중복 제거)\n어떤 메서드가 있는데?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n메서드설명add(value)값을 추가하고 Set 객체를 반환합니다.delete(value)특정 값을 제거하고 성공 여부를 반환합니다 (true/false).has(value)특정 값이 존재하는지 확인하여 불리언 값을 반환합니다.clear()모든 값을 제거합니다.sizeSet에 저장된 값의 개수를 반환하는 속성입니다.forEach(callback)각 요소에 대해 콜백 함수를 실행합니다.values()모든 값을 포함하는 반복자(iterator)를 반환합니다.\n예제 좀 살펴볼까?\nconst mySet = new Set();\nmySet.add(1);\nmySet.add(2);\nmySet.add(2); // 중복된 값은 무시됨\nmySet.add(&quot;hello&quot;);\nconsole.log(mySet); // Set { 1, 2, &#039;hello&#039; }\n \n활용하기 - 배열의 중복값 제거하기\nconst numbers = [1, 2, 3, 4, 4, 5, 5];\nconst uniqueNumbers = [...new Set(numbers)];\nconsole.log(uniqueNumbers); // 출력: [1, 2, 3, 4, 5]\n아하, set에 한번 돌리면 이녀석은 중복이 싹 다 제거되는구나!!\n활용하기 - 교집합, 차집합 찾아내기\nconst setA = new Set([1, 2, 3]);\nconst setB = new Set([3, 4, 5]);\n \n// 교집합 (Intersection)\nconst intersection = new Set([...setA].filter((x) =&gt; setB.has(x)));\nconsole.log(intersection); // 출력: Set {3}\n \n// 차집합 (Difference)\nconst difference = new Set([...setA].filter((x) =&gt; !setB.has(x)));\nconsole.log(difference); // 출력: Set {1, 2}"},"Node-js/Start-Node-js":{"slug":"Node-js/Start-Node-js","filePath":"Node js/Start Node js.md","title":"Start Node js","links":[],"tags":[],"content":"노드세팅하기\nnpm install express mysql2 cors dotenv\n나의 프로젝트 위치: front_class/class1/gserver\ncors:  포트번호가 다를 때, 하나로 융합시켜주는 아이다\ndotenv: 환경설정을 도와주는 파일  .env\n이렇게 하고 node 작업에 들어간다."},"Node-js/fetch와-await":{"slug":"Node-js/fetch와-await","filePath":"Node js/fetch와 await.md","title":"fetch와 await","links":["Node-js/Promiss"],"tags":[],"content":"const fetchWeather = async (city) =&gt; {\n    const url = `api.openweathermap.org/data/2.5/weather${city}&amp;units=metric&amp;appid=0f347a891b27262bf15023a506af4bbe`;\n  \n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Error: ${response.status}`);\n      }\n      const data = await response.json();\n \n      // 온도.\n      const temp = data.main.temp;\n      const temp_Element = document.getElementById(&#039;temp&#039;);\n      temp_Element.textContent = `${temp}°C`;\n \n      \n    } catch (error) {\n      console.error(error.message);\n    }\n  };\n  \n  // 사용 예시\n  fetchWeather(&#039;Suwon&#039;);\n  \n  \nfetch\nfetch는 네트워크 요청을 보내고 결과로 promise객체를 반환한다\n이 promise는 요청이 완료되면 응답 객체(Response)로 해결된다.\nhttp 상태코드, 헤더, 본문 데이터에 접근 할 수 있는 메서드를 제공한다.\npromise?\nPromise는 비동기 작업의 결과를 처리하는 객체로, 콜백 중첩 대신 .then() 체인을 사용하여 가독성을 높인다. 결국 promise는 콜백지옥을 해결해준다. 비동기를 동기화 하기 위해 사용하는 객체다. 실행은 바로 하되 결과값은 나중에 받는 객체라고 볼 수 있다.\nPromiss\nawait\n비동기 함수(async)에서만 사용할 수 있는 것으로, promise가 처리될 때까지 코드 실행을 일시중단한다. \npromise가 해결되면 그 결과값을 반환하고 이후 코드를 계속 실핸한다.\n왜 fetch에서 await가 두번이 필요하지? - 두번 대기해야한다??\n\n\n네트워크 요청 전송 및 응답 헤더 받을 때까지 대기\n첫번째 await fetch(url)는 네트워크 요청을 보낸다.\n또, 서버로부터 응답헤더를 받을 때까지 기다린다.\n여기서는 아직 응답본문은 처리되지 않는다. - 따라서 반환된 응답객체에는 본문데이터를 읽기위한 메서드만 포함되어 있다.\n\n\n본문 데이터를 읽고 파싱\n두번째 await response.json()은 응답 본문 데이터를 읽고 파싱하는 작업을 한다.\n본문 데이터는 스트림 형태로 제공되기때문에 이를 JSON으로 변환하려면 추가 비동기 작업이 필요하다. 그러니까 한번 더 await로 대기해야한다.\n\n\n\ncode example\nasync function fetchData(url) {\n  const response = await fetch(url); // 첫 번째 await: 응답 헤더를 기다림\n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  const data = await response.json(); // 두 번째 await: 본문 데이터를 JSON으로 변환\n  console.log(data);\n}\n \nfetchData(&#039;api.example.com/data&#039;);\n \n\n내 코드를 then방식으로 변환한다면?\nconst fetchWeather = (city) =&gt; {\n  const url = `api.openweathermap.org/data/2.5/weather${city}&amp;units=metric&amp;appid=${api키가 들어가는 부분}`;\n  fetch(url)\n    .then((response) =&gt; {\n      if (!response.ok) {\n        throw new Error(`Error: ${response.status}`);\n      }\n      return response.json(); // 응답 본문을 JSON으로 변환\n    })\n    .then((data) =&gt; {\n      // 날씨 아이콘\n      const iconCode = data.weather[0].icon;\n      const iconUrl = `openweathermap.org/img/wn/${iconCode}@2x.png`;\n      const weatherIconElement = document.getElementById(&#039;weatherIcon&#039;);\n      weatherIconElement.src = iconUrl;\n \n      // 온도\n      const temp = data.main.temp;\n      const temp_Element = document.getElementById(&#039;temp&#039;);\n      temp_Element.textContent = `${temp}°C`;\n \n      // 날씨 컨디션\n      const weatherCondition = data.weather[0].main;\n      const conditionElement = document.getElementById(&#039;condition&#039;);\n      conditionElement.textContent = weatherCondition;\n    })\n    .catch((error) =&gt; {\n      console.error(error.message); // 에러 처리\n    });\n};\n \n// 사용 예시\nfetchWeather(&#039;Suwon&#039;);\n "},"Node-js/json()-메서드":{"slug":"Node-js/json()-메서드","filePath":"Node js/json() 메서드.md","title":"json() 메서드","links":[],"tags":[],"content":"자바스크립트에서 .json()메서드는 fetch API응답 객체에 포함된 메서드다.\n서버에서 json형태로 받은 데이터를 자바스크립트 객체로 변환하는 역할을 한다\n비동기적으로 동작하며,  promise를 반환한다.\n\n\nJSON 데이터를 변환한다\n서버에서 받은 응답데이터가 json형식이면 파싱이 불가능하다\n이를 자바스크립트 객체로 변환한다.\n내부적으로 JSON.parse()라고 볼 수 있다\n\n\nPromise 반환\n비동기 작업을 처리하기위해 Promise를 반환한다\n변환이 완료되면 Promise가 resolved된다. JavaScript객체를 반환한다.\n\n\n주로 Fetch API와 함께 사용된다.\n서버에서 데이터를 가지고와서 클라이언트쪽에서 처리할 때 유용하다\nJSON.parse()랑 뭐가달라?\nFetch API의 response객체에 내장되어있는 .json()은 응답 본문을 읽고 데이터를 파싱한다. 반면에 JSON.parse()는 문자열 형태의 JSON 데이터를 자바스크립트 객체로 직접 변환한다."},"Node-js/json만들고-가져오기":{"slug":"Node-js/json만들고-가져오기","filePath":"Node js/json만들고 가져오기.md","title":"json만들고 가져오기","links":[],"tags":[],"content":"내가 직접 json을 만들어서 서버에서 가져와볼까?\n참고로 지금은 콜백지옥에서 우리를 구원한 promise문법을 공부중이다\n그래서 해당내용이 등장할 예정이다.\njson 만들기\n\n\n프로젝트 폴더 하나 만들기\n\n\nnpm init 하기\n\n\nnpm install express 하기\n추가적으로 나는 http로 접근이 잘안되서 npm install cors를 추가 설치했다\n\n\nserver.js를 만들어서 구현하기\n\n\nconst express = require(&#039;express&#039;);\nconst cors = require(&#039;cors&#039;); // CORS 미들웨어 추가\nconst fs = require(&#039;fs&#039;);\nconst path = require(&#039;path&#039;);\n \nconst app = express();\nconst port = 4000;\n \n// 모든 도메인에서의 요청을 허용\napp.use(cors());\n \napp.get(&#039;/data&#039;, (req, res) =&gt; {\n  const filePath = path.join(__dirname, &#039;data.json&#039;);\n  fs.readFile(filePath, &#039;utf8&#039;, (err, data) =&gt; {\n    if (err) {\n      console.error(&#039;Error reading file:&#039;, err);\n      return res.status(500).json({ error: &#039;Error reading data&#039; });\n    }\n    res.json(JSON.parse(data));\n  });\n});\n \napp.listen(port, () =&gt; {\n  console.log(`Server running at http://localhost:${port}`);\n});\n \n\n위 코드에서 data.json을 찾고있으므로 내가 만들 json파일도 만들어주기\n\n{\n    &quot;id&quot;: 1,\n    &quot;title&quot;: &quot;Sample Post&quot;,\n    &quot;body&quot;: &quot;This is a sample post content.&quot;,\n    &quot;author&quot;: &quot;John Doe&quot;\n}\n\n이제 코드에서 불러가지고 오면된다.  promise를 공부중이었으므로  해당 문법으로 작성했다.\n"},"Node-js/nodemon":{"slug":"Node-js/nodemon","filePath":"Node js/nodemon.md","title":"nodemon","links":[],"tags":[],"content":"nodemon 이란?\nNodemon은 Node.js 개발을 더욱 효율적으로 만들어주는 도구로, 코드 변경 시 서버를 자동으로 재시작합니다. 이를 통해 개발자는 수동으로 서버를 재시작할 필요 없이 실시간으로 변경 사항을 확인할 수 있습니다. 아래는 Nodemon의 설치 및 사용 방법을 단계별로 설명한 가이드입니다.\n1. Nodemon 설치\nNodemon은 글로벌 또는 로컬로 설치할 수 있습니다.\n글로벌 설치\n글로벌 설치를 통해 시스템 전체에서 Nodemon을 사용할 수 있습니다:\nbash\nnpm install -g nodemon\n설치 후, 다음 명령어로 설치 확인:\nbash\nnodemon --version\n로컬 설치\n특정 프로젝트에서만 Nodemon을 사용하려면 로컬로 설치합니다:\nbash\nnpm install --save-dev nodemon\n로컬 설치 후에는 npx를 통해 실행하거나 npm 스크립트를 설정해야 합니다\n2. Nodemon 기본 사용법\nNodemon은 Node.js 애플리케이션 실행 시 node 대신 사용됩니다.\n직접 실행\n애플리케이션 파일이 app.js라면 다음 명령어로 실행합니다:\nbash\nnodemon app.js\nnpm 스크립트 활용\npackage.json에 다음과 같은 스크립트를 추가하여 편리하게 실행할 수 있습니다:\njson\n&quot;scripts&quot;: {   &quot;dev&quot;: &quot;nodemon app.js&quot; }\n이후 아래 명령어로 실행 가능합니다:\nbash\nnpm run dev\n3. Nodemon 옵션 및 설정\nNodemon은 다양한 옵션과 설정 파일을 통해 커스터마이징할 수 있습니다.\n명령줄 옵션\n특정 파일 확장자를 감시하려면 --ext 옵션을 사용합니다:\nbash\nnodemon --ext js,json,html app.js\n설정 파일 (nodemon.json)\n프로젝트 루트에 nodemon.json 파일을 생성하여 설정을 정의할 수 있습니다:\njson\n{   &quot;watch&quot;: [&quot;src&quot;],  &quot;ext&quot;: &quot;js,json&quot;,  &quot;ignore&quot;: [&quot;logs/&quot;],  &quot;delay&quot;: &quot;2&quot; }\n이를 통해 특정 디렉토리나 파일을 감시하거나 무시할 수 있습니다\n4. Nodemon 종료\n실행 중인 Nodemon을 종료하려면 터미널에서 Ctrl + C를 누릅니다\n5. Nodemon의 장점\n\n\n자동 재시작: 코드 변경 시 서버를 자동으로 재시작하여 개발 시간을 단축합니다.\n\n\n다양한 파일 지원: JavaScript뿐만 아니라 JSON, HTML, CSS 등 다양한 파일 변경도 감지합니다.\n\n\n유연한 설정: 특정 파일이나 디렉토리를 감시하거나 무시하는 등 맞춤형 설정이 가능합니다\n\n\n6. 실전 예제\nExpress.js 기반 애플리케이션을 Nodemon으로 실행하는 예제:\njavascript\nconst express = require(&quot;express&quot;); const app = express(); app.get(&quot;/&quot;, (req, res) =&gt; {   res.send(&quot;Hello, World!&quot;); }); const port = 3000; app.listen(port, () =&gt; {   console.log(`Server running on port ${port}`); });\n위 코드를 app.js로 저장한 후 다음 명령어로 실행:\nbash\nnodemon app.js\nNodemon은 Node.js 개발자에게 필수적인 도구로서, 개발 과정에서 반복 작업을 줄이고 생산성을 높이는 데 큰 도움을 줍니다."},"Node-js/npm-sanitize-html":{"slug":"Node-js/npm-sanitize-html","filePath":"Node js/npm sanitize html.md","title":"npm sanitize html","links":[],"tags":[],"content":"출력 정보를 살균/소독하는 기능\nsanitize-html\nnpm에서 찾은 모듈이다.\nwww.npmjs.com/package/sanitize-html\nnpm으로 패키지 관리 시작하기\nnpm init\n\n나의 애플케이션을 npm 으로 관리할 수 있게 된다.\n내가 사용하고픈 패키지 추가하기\nnpm install -S sanitize-html\n\n-S 라고하면 이 프로젝트에서 사용할 수 있게 작은 부품을 설치하게된다.\n이러고나면 node_modules폴더에 오만가지가 생긴다\n당연히 sanitize-html폴더도 있다\npackage.json파일에 dependencies에도 확인이 된다 (의존 확인)\npackage.json\n내 프로젝트가 어떠한 외부 소프트웨어들에 의존하고 있는지를 확인할 수 있다.\n나는 sanitize-html을 깔았지만, 걔가 의존하고있는 모든것을 얘가 깔아준다.\n또 그들이 의존하는 것들도 모두 설치할기때문에 node_modules폴더가 엄청나게 요소가 많은거다"},"Node-js/server.js-만들기":{"slug":"Node-js/server.js-만들기","filePath":"Node js/server.js 만들기.md","title":"server.js 만들기","links":[],"tags":[],"content":"DB 연결하기\n//db 접속이 가능한 node 파일을 만들었다. 25.04.11\n \n//익스프레스를 사용하자. 한번 콜해서.\nconst express = require(&quot;express&quot;);\nconst app = express();\n \n//mysql 접속하게 도와준다\nconst mysql = require(&quot;mysql2&quot;);\n \n//cors도 사용하겠다고 선포한다  --  나뉜 나의 많은 포트들을 하나로 융합한다. \nconst cors = require(&quot;cors&quot;);\napp.use(cors());\n \n//json을 주고받아야하기때문에 선포를 해준다.\napp.use(express.json());\n \nconst db = mysql.createConnection({\n    host: &#039;34.41.55.78&#039;,\n    user: &#039;root&#039;,\n    password: &#039;&lt;여기는 비밀번호 들어갈 자리&gt;&#039;,\n    database: &#039;root&#039;,\n})\n \n \ndb.connect(err=&gt;{\n    if(err) {\n        console.error(&#039;db 연결 실패&#039;,err);\n    } else {\n        console.log(&#039;db 연결 성공&#039;);\n    }\n})\n \napp.listen(8881, ()=&gt;{\n    console.log(&#039;8881에서 대기중&#039;);\n})\n읽는 기능 넣기\n//셀렉트를 해서 보여달라고 할꺼야. 그러면 무조건 get방식이지.\n//날짜순으로 내림차순을해서 최근내용이 위로 올라오게 할거야.\napp.get(&#039;/guest&#039;,(req,res)=&gt;{\n    db.query(`SELECT * FROM guest ORDER BY created_at DESC`, (err, results)=&gt;{\n        res.json(results);\n    });\n});\n쓰기 기능 넣기\napp.post(&#039;/guest&#039;,(req,res)=&gt;{\n    const { name, message } = req.body;\n    db.query(`INSERT INTO guest (name, message) VALUES (?, ?)`, [name, message], (err)=&gt;{\n        if(err) res.status(500).send(err);\n    });\n});"},"Node-js/이터레이션":{"slug":"Node-js/이터레이션","filePath":"Node js/이터레이션.md","title":"이터레이션","links":[],"tags":[],"content":"데이터 컬렉션을 순회하기위해 만들어진 규칙이다.\n이터레이션 프로토콜을 준수한 객체는 for…of문으로 순회할 수 있고 spread문법의 피연산자가 될 수 있다.\n이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이 있다.\n \n[Symbol.iterator]()\n \n//위는 아래를 리턴한다\n \n{\n\tnext(){\n\t\treturn {\n\t\t\tvalue: any,\n\t\t\tdone: boolean\n\t\t};\n\t}\n}\n \n \n이터러블\n이터러블 프로토콜을 준수한 객체를 이터러블이라고 한다.  준수했다는 것은 Symbol.iterator()를 가졌다는 뜻이다\n이터러블은 Symbol.iterator메서도를 구현하거나 프로토타입 체인에 의해 상속한 객체를 말한다.\nconst array = [1,2,3];\nconsole.log(Symbol.iterator in array);\n \nfor(const item of array){\n\tconsole.log(item);\n}\n\nfor…of 문 사용가능\nSpread (값을 뿌리는 것) 문법 대상으로 사용 가능\n\n위 코드는 이터러블이기때문에 for…of문으로 돌리는 것이 가능한 것을 볼 수 있다.\n반면에 객체같은건 순서보증이 되지않기때문에 안된다.\n이터레이터\n이터레이터 프로토콜을 next메서드를 자동으로 갖는다.\nnext메서드를 호출하면 이터러블을 순회하면서 value, done프로퍼티를 갖는 객체를 반환한다.\nconst array = [1, 2, 3]; \nconst iterator = array[Symbol.iterator](); \nconsole.log(&#039;next&#039; in iterator); \n \nlet iteratorResult = iterator.next(); \nconsole.log(iteratorResult); // {value: 1, done: false}\nconst array = [1,2,3];\nconsole.log(Symbol.iterator in array);\nconsole.log(Symbol.iterator);\n \nfor(const item of array){\n\tconsole.log(item);\n}\n \nconsole.log(&quot;******&quot;);\n \nconst iterator = array[Symbol.iterator]();\nconsole.log(&#039;next&#039; in iterator);\nconsole.log(iterator);\n \n// console.log(iterator.next());\n// console.log(iterator.next());\n// console.log(iterator.next());\n// console.log(iterator.next());\n \nlet next = iterator.next();\nwhile(!next.done){\n\tconsole.log(next.value);\n\tnext = iterator.next();\n}\n위처럼 while문으로 반복문처럼 구현할 수도 있다\n이 내용은 내가 처음으로 이터레이터를 공부했을때 엄청 궁금해서 찾아봤던건데 오랜만에 하니까 재밌다.\n빌트인 이터러블\nArray,\nString,\nMap,\nSet,\nTypedArray(Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array),\nDOM data structure(NodeList, HTMLCollection),\nArguments\n위의 내용이 ES6에서 지원하는 빌트인 이터러블이다.\n\nU가 붙어있는건 unsigned를 의미한다.\n\n \n// 문자열은 이터러블이다. \nconst string = &#039;hi&#039;; \n// 이터러블은 Symbol.iterator 메소드를 소유한다. \n// Symbol.iterator 메소드는 이터레이터를 반환한다. \niter = string[Symbol.iterator](); \n \n// 이터레이터는 next 메소드를 소유한다. \n// next 메소드는 이터레이터 리절트 객체를 반환한다. \nconsole.log(iter.next()); // {value: &quot;h&quot;, done: false} \nconsole.log(iter.next()); // {value: &quot;i&quot;, done: false} \nconsole.log(iter.next()); // {value: undefined, done: true} \n \n// 이터러블은 for...of 문으로 순회 가능하다. \nfor (const letter of string) { console.log(letter); }\nfor…of 문의 동작방식\nconst it2 = [ 1, 2, 3];\nconst itt = it2[Symbol.iterator]();\n \nfor(;;){\n    const res = itt.next();\n    if(res.done) break;\n \n    console.log(res);\n}\n참고로 여기서for(;;)이부분은 초기화, 조건, 증감을 모두 생략한 상태로 무한루프를 말한다.\n커스텀 이터러블\n일반 객체는 이터러블이 아니기떄문에 Symbol.iterator 메서드가 없다.\n그래서 직접 만들었다.\n굉장히 이해하기 힘들었는데, 재미있는 코드였다.\n피보나치수열을 만들기위한 아래 코드를 분석해본다.\n \nconst fibonacci = {\n    [Symbol.iterator](){\n        let [ pre, current ] = [ 0, 1 ];\n        const max = 100; // 최대\n        \n        return {\n            next(){\n                [pre, current] = [current, pre+current];\n                return{\n                    value: current,\n                    done: current &gt;= max\n                }\n            }\n        }\n    }\n}\n \n \nfor( const num of fibonacci ) {\n    console.log(num);\n}\n이렇게 피보나치 수열을 커스텀해서 사용한다\n아래에있는 for ..of 문에서 fibonacci의 Symbol.iterator을 찾을테니까 위에서 정의해준다.\n거기서 보면 return에  next()에,  return이 있고, 그 안에 value가 있다.\n그걸 아래에있는 for…of문에서 num으로 받는것이다.\n놀랍게도, 이런것도 가능하다\nconst result = [...fibonacci];\nconsole.log(result);\n \nconst [first, second, ...rest] = fibonacci;\nconsole.log(first, second, rest);\n😝\n공부를 하다보니까, 많은 커스텀 이터러블이 비슷하게 생겼다\n너무 어려우면 대략의 형태를 그냥 익혀두는 것도 좋을 것 같다\nconst myIterable = {\n    data: [10, 20, 30],\n    [Symbol.iterator]() {\n        let index = 0;\n        const data = this.data;\n        return {\n            next() {\n                if (index &lt; data.length) {\n                    return { value: data[index++], done: false };\n                } else {\n                    return { value: undefined, done: true };\n                }\n            },\n        };\n    },\n};\n \nfor (const value of myIterable) {\n    console.log(value); // 출력: 10, 20, 30\n}\n이터러블이면서 이터레이터인 객체 만들기\n이걸 이해하기전에 먼저 이터러블과 이터레이터를 정확하게 구분할 줄 알아야한다.\n\n\n이터러블\nSymbol.iterator 메서드를 가진 객체를 말한다.\n호출이 되면 이터레이터 객체를 반환한다\nfor…of,  스프레드 등으로 순회할 수 있는 객체를 말한다\n\n\n이터레이터\nnext()메서드를 가진 객체를 말한다\nnext()메서드는 {value, done}형태의 객체를 반환한다\nvalue는 현재 값을 보여주고, done은 순회가 끝났는지를 알려주는 불리언 값이다\n\n\nconst fibonacciF = (max) =&gt; {\n    let [pre, cur] = [0, 1];\n \n    return {\n        [Symbol.iterator]() {\n            return this; // 자신을 반환 (이터러블이면서 이터레이터)\n        },\n        next() {\n            [pre, cur] = [cur, cur + pre]; // 피보나치 수열 계산\n            return {\n                value: cur,\n                done: cur &gt;= max // 현재 값이 max 이상이면 done: true\n            };\n        }\n    };\n};\n위 코드에서 fibonacciF는 [Symbol.iterator]를 가지고 있으니까 이터러블인건 일단 정확해.\n근데 next()메서드도 가지고있네? 그러면 이터레이터이기도한거야.\n여기서 return 에 Symbol.iterator메서드를 가지고 있다는 것이 아주 중요한데, 반환된 객체에서 Symbol.iterator는 자기자신을 반환하고있어. 이때문에 해당 객체가 자체적으로 이터러블이자 이터레이터라는거야.\n커스텀 이터러블 vs 이터러블이면서 이터레이터\nconst iterable = {\n  [Symbol.iterator]() {\n    let [pre, cur] = [0, 1];\n    const max = 10;\n \n    return {\n      next() {\n        [pre, cur] = [cur, pre + cur];\n        return { value: cur, done: cur &gt;= max };\n      }\n    };\n  }\n};\n \nconst iterator = iterable[Symbol.iterator](); // 이터레이터 객체 생성\n \nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: 5, done: false }\nconsole.log(iterator.next()); // { value: 8, done: false }\nconsole.log(iterator.next()); // { value: 13, done: true } // 순회 종료\n그냥 커스텀 이터러블이다. 지금까지 공부한 것처럼 이터러블의 역할만 하기때문에 안에서 내용을 꺼내쓰려면 const iterator = iterable[Symbol.iterator]();가 반드시 필요했다.\nconst iterableIterator = (max) =&gt; {\n  let [pre, cur] = [0, 1];\n \n  return {\n    [Symbol.iterator]() {\n      return this; // 자기 자신을 반환 (이터러블이면서 이터레이터)\n    },\n    next() {\n      [pre, cur] = [cur, pre + cur];\n      return { value: cur, done: cur &gt;= max };\n    }\n  };\n};\n \nconst iterator = iterableIterator(10); // 바로 사용 가능 (자체적으로 이터러블 + 이터레이터)\n \nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: 5, done: false }\nconsole.log(iterator.next()); // { value: 8, done: false }\nconsole.log(iterator.next()); // { value: 13, done: true } // 순회 종료\n \n이터러블이면서 이터레이터인 상황이다. 이 경우에는 따로 호출할 필요가없이 그냥 사용할 수 있게 되는 것이다.\n큰 내용은아니고 그냥 이정도였다. 너무 어렵게 접근할 필요가없었음!\n결론\nfor ..of 는 이터러블 요소를 순회하면서 요소에 특정한 일을하는 반복문.\nfor ..in 은 순서가 보장되지않는 객체와 같은 것들을 순회하면서 특정한 일을 하는 반복문"},"React로-만드는-웹사이트":{"slug":"React로-만드는-웹사이트","filePath":"React로 만드는 웹사이트.md","title":"React로 만드는 웹사이트","links":["react/Start-React","Node-js/Start-Node-js","react/react-컴포넌트-만들기","react/useEffect","react/React-ClassName","react/흐르는-슬라이드--and--scroll-대응-모션","react/Framer-Motion","open-api/GCP","sql/DBeaver","Node-js/server.js-만들기"],"tags":[],"content":"리액트 시작하기\nStart React\n노드 세팅해두기 (gserver)\nStart Node js\n리액트 파일정리 + 컴포넌트 만들기\nreact 컴포넌트 만들기\nuseEffect\nuseEffect\nclass name\nReact ClassName\nSlide &amp; Scroll\n흐르는 슬라이드 &amp; scroll 대응 모션\nFramer Motion\nFramer Motion\nGCP\nGCP\nDBeaver\nDBeaver\nserver.js만들어서 DB랑 연결하기\nserver.js 만들기"},"Spring-boot/Annotations":{"slug":"Spring-boot/Annotations","filePath":"Spring boot/Annotations.md","title":"Annotations","links":[],"tags":[],"content":"샘플 프로젝트하면서 사용한 어노테이션을 모아봤다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n어노테이션 이름설명@Override메서드 오버라이드를 명시@AllArgsConstructor생성자@NoArgsConstructor디폴트생성자(파라미터가 없는 생성자) 만들어줌@ToStringOverride되는 toString메서드@Controller컨트롤러 생성@Slf4jlog.info()사용을 위함@GetMapping(”/”)@PostMapping(”/’)라우팅@Autowired스프링 부트가 미리 생성해둔 객체를 자동으로 연결해준다.@Autowiredprivate ArticleRepository articleRepository;@Entitydb가 해당 객체를 인식할 수 있도록 Entity 정의@Columndb의 열 하나씩 정의함@Idprimary key 지정@GeneratedValue하나씩 자동으로 수가 늘어나게끔 지정@PathVariable이변수는 path로 부터 가져온 변수다라는걸 알려주기위함@RequestBodybody에서 찾아와라.@Transactional해당 메서드를 트랜젝션으로 묶어준다. 따라서 중간에 수행되지못한게 있으면 자동으로 rollback을 시켜서 처음으로 돌려준다. (트랜잭션이란 그런아이니까)"},"Spring-boot/CRUD---삭제":{"slug":"Spring-boot/CRUD---삭제","filePath":"Spring boot/CRUD - 삭제.md","title":"CRUD - 삭제","links":[],"tags":[],"content":"데이터 삭제를 구현하고 직접 확인하라\n흐름\n\n삭제 요청전달\n디비에서 찾아서 삭제\n리다이렉트보냄\n\n\ndto는 필요없어. 어차피 url 라우팅정보야.\n지우는거라서 entity등장할 필요도 없어\n\n\n상세 페이지에서 delete버튼을 만들어라\n&lt;a href=&quot;/articles/{{article.id}}/delete&quot; class=&quot;btn btn-primary&quot;&gt;Delete&lt;/a&gt;\ndeleteMapping같은걸 html을 지원하지않으니까 그냥 get방식을 이용하려고 a태그를 썼어.\n\n\n이제 controller 에서 할일을 설정해야겠어\n @GetMapping(&quot;/articles/{id}/delete&quot;)\n    public String delete(@PathVariable Long id){\n        log.info(&quot;삭제 요청 &quot;);\n        \n        //삭제 대상 가져온다\n        Article target = articleRepository.findById(id).orElse(null);\n        log.info(target.toString());\n        \n        //대상을 삭제 한다\n        if(target!=null){\n            articleRepository.delete(target);\n        }\n \n        //삭제 완료 되었으면 결과 페이지로 리다이렉트 한다\n        return &quot;redirect:/articles&quot;;\n    }\ndb랑 일할때는 항상 repository를 이용해\n\n\n삭제 완료 메시지 정도 남겨주는게 좋겠지. - RedirectAttributes: 일회성으로 삭제메시지 띄우기 가능\n @GetMapping(&quot;/articles/{id}/delete&quot;)\n    public String delete(@PathVariable Long id, RedirectAttributes rttr){\n        log.info(&quot;삭제 요청 &quot;);\n        //1. 삭제 대상 가져온다\n        Article target = articleRepository.findById(id).orElse(null);\n        log.info(target.toString());\n        //2. 대상을 삭제 한다 (있는지를 먼저 확인안하면 시스템이 스탑된다)\n        if(target!=null){\n            //2-1 \n            articleRepository.delete(target);\n            //2-2 한번 쓰고 사라지는 휘발성으로 하나 만들어준다\n            rttr.addFlashAttribute(&quot;msg&quot;,&quot;삭제가 완료되었습니다!&quot;);\n        }\n \n        //3. 삭제 완료 되었으면 결과 페이지로 리다이렉트 한다\n        return &quot;redirect:/articles&quot;;\n    }\n위처럼 주석을 잘 적어주면 아주 편해.\n\n\n\n레이아웃쪽 header한테도 알럿창 하나 넣어주고.\n\n&lt;!--alert msg--&gt;\n{{#msg}}\n    &lt;div class=&quot;alert alert-primary alert-dismissible&quot;&gt;\n        {{msg}}\n        &lt;button class=&quot;btn-close&quot; data-bs-dismiss=&quot;alert&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt;\n    &lt;/div&gt;\n{{/msg}}"},"Spring-boot/CRUD---수정":{"slug":"Spring-boot/CRUD---수정","filePath":"Spring boot/CRUD - 수정.md","title":"CRUD - 수정","links":[],"tags":[],"content":"데이터 수정 폼 만들기\n생성과 조회를 했으니 이제는 수정을 해보자\n데이터 상세페이지에 수정하기 기능만들기\n\n\n\n데이터 상세페이지에서 수정하기 링크 작성\n&lt;a href=&quot;/articles/{{article.id}}/edit&quot; class=&quot;btn btn-primary&quot;&gt;Edit&lt;/a&gt;\n\n\n컨트롤러에서 각각의 설정을한다\n@GetMapping(&quot;/aricles/{id}/edit&quot;)\n    public String edit(@PathVariable Long id, Model model){\n        //수정할 데이터를 먼저 가져오자 \n        Article articleEntity = articleRepository.findById(id).orElse(null);\n        \n        //모델에 데이터를 등록 !!\n        model.addAttribute(&quot;article&quot;, articleEntity);\n        \n        //view page\n        return &quot;articles/edit&quot;;\n    }\n\nview page로 연결되게 한다\n수정할 데이터를 repository를 이용해서 가져온다 — 여기서 @PathVariable 이용하는거 잊지말자!\n모델에 데이터를 등록하자 model도 불러오고\n\n\n\nedit.mustach파일 만들기 ( create파일과 비슷하게 생겼으니까 그대로 가져와)\n\n\n잘 나올 수 있게 edit파일을 제작하자\n{{&gt;layouts/header}}\n \n{{#article}}\n&lt;form action=&quot;&quot; method=&quot;post&quot; class=&quot;container py-5&quot;&gt;\n    &lt;div class=&quot;mb-3&quot;&gt;\n        &lt;label class=&quot;form-label&quot;&gt;title&lt;/label&gt;\n        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;title&quot; value=&quot;{{title}}&quot;&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;mb-3&quot;&gt;\n        &lt;label class=&quot;form-label&quot;&gt;content&lt;/label&gt;\n        &lt;textarea name=&quot;content&quot; rows=&quot;3&quot; class=&quot;form-control&quot;&gt;{{content}}&lt;/textarea&gt;\n    &lt;/div&gt;\n    &lt;button class=&quot;btn btn-primary&quot;&gt;submit&lt;/button&gt;\n    &lt;a href=&quot;/articles/{{id}}&quot; class=&quot;btn btn-secondary&quot;&gt;Back&lt;/a&gt;\n&lt;/form&gt;\n{{/article}}\n \n{{&gt;layouts/footer}}\n \n\n\n\n데이터 수정하기\n수정된 데이터를 데이터 베이스로 갱신하고 이를 확인해보자.\n자꾸 껐다키는데 데이터를 생성해야하니까 귀찮아\n더미데이터를 만들자 (/Users/yunhyegyeong/Developer/firstproject/src/main/resources/data.sql)\nINSERT INTO article(id, title, content) VALUES (1, &quot;봄&quot;, &quot;꽃이 활짝.&quot;);\nINSERT INTO article(id, title, content) VALUES (2, &quot;여름&quot;, &quot;바다는 푸르다.&quot;);\nINSERT INTO article(id, title, content) VALUES (3, &quot;봄&quot;, &quot;산이 물들어요.&quot;);\n→ 고생은 했지만 안돼. 버전이 지원을 하지않나봐.\n그래서 그냥 제끼고.\n \n    @PostMapping(&quot;/articles/update&quot;)\n    public String update(ArticleForm form){\n        log.info(form.toString());\n \n        //dto-&gt; entity\n        Article articleEntity = form.toEntity();\n        log.info(articleEntity.toString());\n \n        //entity --&gt; db\n            //수정하는거니까, 있는걸 바꿔야한다 db에서 기존 데이터를 가져온다\n            Article target = articleRepository.findById(articleEntity.getId()).orElse(null);\n \n            //기존데이터의 값을 갱신한다 .. db에서 확인해봐 진짜야\n            if(target!=null){\n                articleRepository.save(articleEntity);\n            }\n \n        //redirect\n        return &quot;redirect:/articles/&quot; + articleEntity.getId();\n    }"},"Spring-boot/CRUD---조회":{"slug":"Spring-boot/CRUD---조회","filePath":"Spring boot/CRUD - 조회.md","title":"CRUD - 조회","links":[],"tags":[],"content":"데이터 조회하기 with JPA\n지금까지 공부한건 데이터 생성과정.\n이제는, db에 저장된걸 화면에서 보고싶다\n데이터 조회의 흐름\n\n\n사용자가 브라우저를 통해 데이터 요청 /article/1\n그 요청 url을 컨트롤러가 받아 (라우팅만 따내겠다는거다)\n\n값을 다루는게 아니라, url의 정보를 받는거니까 dto같은건 안나와.\n\n\n필요한 정보(url에 있겠지)를 리파지토리에게 전달해 findById(1) - 1번 레코드 찾아와\n리파지토리는 디비에 요청,\n디비는 그걸 찾아서 엔티티로 내줘 - 컨트롤러가 먼저 받아.\n컨트롤러가 받은다음에 그걸 처리할걸 처리해, 이걸 모델이 받는다\n그거를 이제 view에서 받아서 최종적으로 view화면을 클라이언트인 브라우저로 보내줌\n\nRead 만들기 과정(db조회)\n\n\n컨트롤러에 매핑만들기 - 우리는 /articles/1, 이런식으로 접근할거야\n@GetMapping(&quot;/articles/{id}&quot;)\n요기 아이디 위치에 들어가는것이 변하는 수야~ 이런느낌이다(변수지정)\n\n\npath에서 넘어온 변수값이라는걸 알려주기위해 어노테이션 사용\n@GetMapping(&quot;/articles/{id}&quot;)\n    public String show(@PathVariable Long id){\n        return &quot;&quot;;\n    }\n\n\n한번 잘 들어오는지 찍어볼까?\n @GetMapping(&quot;/articles/{id}&quot;)\n    public String show(@PathVariable Long id){\n        log.info(&quot;***id=&quot;+id);\n        return &quot;&quot;;\n    }\n위처럼 적고나서 /articles/1000으로 접속하니 진짜로 로그창에 1000번이 잘 나오더라고.\n\n\n아이디로 데이터 찾기\n데이터 가져오는애는 리파지토리야.\n @GetMapping(&quot;/articles/{id}&quot;)\n    public String show(@PathVariable Long id){\n        log.info(&quot;***id=&quot;+id);\n \n        // id로 데이터 가져옴\n        Article articleEntity = articleRepository.findById(id).orElse(null);\n \n        return &quot;&quot;;\n    }\n위에있는 orElse는 값없으면 null하자는 거야.\n\n\n가져온 데이터를 모델로 등록\n@GetMapping(&quot;/articles/{id}&quot;)\n    public String show(@PathVariable Long id, Model model){\n        log.info(&quot;***id=&quot;+id);\n \n        // id로 데이터 가져옴\n        Article articleEntity = articleRepository.findById(id).orElse(null);\n \n        // 가져온 데이터를 모델에 등록\n        model.addAttribute(&quot;article&quot;, articleEntity);\n        \n        return &quot;&quot;;\n    }\n\n\n보여줄 최종 페이지를 설정한다\n@GetMapping(&quot;/articles/{id}&quot;)\n    public String show(@PathVariable Long id, Model model){\n        log.info(&quot;***id=&quot;+id);\n \n        // id로 데이터 가져옴\n        Article articleEntity = articleRepository.findById(id).orElse(null);\n \n        // 가져온 데이터를 모델에 등록\n        model.addAttribute(&quot;article&quot;, articleEntity);\n \n        // 보여줄 페이지를 설정\n        return &quot;show&quot;;\n    }\n\n\nshow.mustache파일을 제작한다\n이미 불러올 header, footer 들이 있으면 그런거 넣으면되지.\n{{#article}} \n    &lt;tr&gt;\n        &lt;th scope=&quot;row&quot;&gt;1&lt;/th&gt;\n        &lt;td&gt;dog&lt;/td&gt;\n        &lt;td&gt;so cute!&lt;/td&gt;\n    &lt;/tr&gt;\n{{/article}}\n위와같이 (모델에 등록된_)article을 여기서 사용할거야~\n\n\n오류가 나서 할수없이 entity에 디폴트 생성자 추가\n@Entity //이래먀만 db가 해당 객체를 인식할 수 있다.\n@AllArgsConstructor\n@NoArgsConstructor // 디폴트 생성자를 추가함 &lt;-----------이거\n@ToString\npublic class Article {\n\n\n\n데이터 목록 조회하기\ndb속 모든 article을 조회해볼까?\n단일 데이터가아닌, 여러개의데이터를 조회하고싶다\n이전과 비슷하지만 반환하는데 엔티티가 아닌 리스트다(엔티티의 묶음)\n\n\n\n브라우저의 요청을 받는다\nlocalhost:8080/articles  라고 들어온거야\n@GetMapping(&quot;/articles&quot;)\n    public String index(){\n        return &quot;&quot;;\n    }\n\n\n컨트롤러 내부에서 모든 아티클 가져오기 findAll()\n@GetMapping(&quot;/articles&quot;)\n  public String index(){\n        \n        //모든 아티클 가져오기\n        List&lt;Article&gt; articleEntityList = articleRepository.findAll();\n        \n    }\n여기서 List를 써야하는데, findAll()이 반환하는 데이터는 Iterable이래. 타입을 바꿔줘야해.\n그러니 인터페이스에가서 Crud~~의 메서드의 리턴타입을 재정의 해줘야되네.\npublic interface ArticleRepository extends CrudRepository&lt;Article, Long&gt; {\n    @Override\n    ArrayList&lt;Article&gt; findAll();\n}\n[타입이 안맞으니까 해결법들이 있다면…]\n\ncasting을 해준다. = (List) articleRepository.findAll();을 이용한다.\nIterable타입으로 지정해버린다 Iterable articleEntityList =\nArrayList타입으로 반환할 수 있도록 인터페이스 자체를 수정한다\n\n\n\n가져온 아티클의 묶음을 뷰로 전달하기\n@GetMapping(&quot;/articles&quot;)\n    public String index(Model model){\n        \n        //모든 아티클 가져오기\n        List&lt;Article&gt; articleEntityList = articleRepository.findAll();\n        \n        //가져온 아티클 묶음을 뷰로 전달하기\n        model.addAttribute(&quot;articleList&quot;, articleEntityList);\n        \n    }\n\n\n뷰 페이지를 설정하기\n@GetMapping(&quot;/articles&quot;)\n    public String index(Model model){\n        \n        //모든 아티클 가져오기\n        List&lt;Article&gt; articleEntityList = articleRepository.findAll();\n        \n        //가져온 아티클 묶음을 뷰로 전달하기\n        model.addAttribute(&quot;articleList&quot;, articleEntityList);\n        \n        //뷰 페이지를 설정하기\n        return &quot;articles/index&quot;;\n    }\n\n\nindex.mustache로 지정하기\n{{#articleList}}\n     &lt;tr&gt;\n        &lt;th scope=&quot;row&quot;&gt;{{id}}&lt;/th&gt;\n        &lt;td&gt;{{title}}&lt;/td&gt;\n        &lt;td&gt;{{content}}&lt;/td&gt;\n     &lt;/tr&gt;\n{{/articleList}}\n그냥 위처럼만 해도 알아서 안쪽 내용이 반복이된다\n만약에 데이터가 40개 있으면, 40번의 id,title,content가 나오는거지.\n\n"},"Spring-boot/CRUD와-SQL쿼리":{"slug":"Spring-boot/CRUD와-SQL쿼리","filePath":"Spring boot/CRUD와 SQL쿼리.md","title":"CRUD와 SQL쿼리","links":[],"tags":[],"content":"\n자바에서는 JPA를 가지고 SQL을 제어하고,\n노드는 시퀄라이저를 이용하고,\n파이썬은 장고를 이용하고…\n사실 자바에서도 뒤에가 h2가되던 oracle이되던 mysql이되던 상관이없어.\n그저 우리는 JPA만 만지면되자나.\noracle전용,  h2전용..이런걸 짜는것보다 훨씬 효율적이지.\n생각해봐. 실무에서 db단이 달라지면 어쩔껀데.\n시퀄라이져, JPA같은것들을 ORM이라고하거든. 이거 좋긴한데, 어찌되었던 번역되어서 거쳐서 나가니까 불편하기도해.\n\nORM모델의 장점: 편하다. (SQL문법 몰라도되니까)\nORM모델의 단점: 느리다. (번역을 해야되자나…) 또, ORM이 바뀌면 또다른 명령어를 외워야하자나\n\n\n데이터 crud의  sql쿼리문\n\n/Users/yunhyegyeong/Developer/firstproject/src/main/resources/application.properties\n로그에서 sql문 확인하는 설정\n#JPA 로깅 설정\n# 디버그 레벨로 쿼리 출력\nlogging.level.org.hibernate.SQL = DEBUG\n# 이쁘게 보여주기\nspring.jpa.properties.hibernate.format_sql=true\n# 파라미터 보여주기\nlogging.level.org.hibernate.SQL=DEBUG\nlogging.level.org.hibernate.orm.jdbc.bind=TRACE\ndb접속할때마다 바꿔야하는 값 고정하기\n#DB URL 고정 설정\n# 유니크 url 생성 x\nspring.datasource.generate-unique-name=false\n# 고정 url설정\nspring.datasource.url=jdbc:h2:mem:testdb\ndb가 아이디값을 자동으로 생성할 수 있게.\n //private Long id; //구분하기위한 대표값(기본키)\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY) // db가 id를 자동생성한다 \n    private Long id;\nentity에 전략을 설정한다. 이건 진짜 필수다."},"Spring-boot/Form-데이터-주고받기":{"slug":"Spring-boot/Form-데이터-주고받기","filePath":"Spring boot/Form 데이터 주고받기.md","title":"Form 데이터 주고받기","links":[],"tags":[],"content":"사용자로부터 폼데이터를 받고 이를 컨트롤러에서 확인하는 것이 목표.\n이제 게시판 만들기를 시작해볼까!?\nCreate, Read, Update, Delete\n컨트롤러 앞에 DTO를 붙여줘야한다.\n쿼리나 뭐나 정보가 날라붙어올때, 그걸 담는 놈인 DTO를 붙여줘야한다\n즉, 컨트롤러가 받기전에 DTO를 설계해줘야한다.\n클라이언트 → 서버 → 데이터베이스\n클라이언트가 값을 입력하고 DTO가 그 값을 받도록 하기\n\n\narticles/new.mustache를 만들고 그 안에서 form태그를 만들었어 데이터 보낼 수 있게\n\n액션과 메서드를 잘 적었어.\n만약에 여기서 1.jpg를 불렀어. 그러면 걔는 어디있어야할까? - static폴더😍\n\n\n\n컨트롤러쪽에서 postmapping()\n\n\ndto패키지만들기 ArticleForm 클래스 만들기\n\n던져진 데이터들을 받는 아이: DTO\n어디에만들어?\n\n\n\n\npackage com.example.firstproject.dto;\n \npublic class ArticleForm {\n    private String title;\n    private String content;\n \n    public ArticleForm(String title, String content) {\n        this.title = title;\n        this.content = content;\n    }\n \n    @Override\n    public String toString(){\n        return &quot;ArticleForm{&quot; +\n                &quot;title=&#039;&quot; + title + &#039;\\\\&#039;&#039; +\n                &quot;, content=&#039;&quot; + content + &#039;\\\\&#039;&#039; +\n                &#039;}&#039;;\n    }\n}"},"Spring-boot/IoC,--DI,-AOP":{"slug":"Spring-boot/IoC,--DI,-AOP","filePath":"Spring boot/IoC,  DI, AOP.md","title":"IoC,  DI, AOP","links":[],"tags":[],"content":"우리는 객체를 만들지도 않고 어떻게 썼을까?\n IoC Container안에 Controller, Service, Repository등을 가지고있어.\nAOP\n부가 기능을 주입하는 클래스"},"Spring-boot/Lombok":{"slug":"Spring-boot/Lombok","filePath":"Spring boot/Lombok.md","title":"Lombok","links":[],"tags":[],"content":"여러 필수코드를 단순화 할 수 있고, 코드 Refactoring(코드개선)가능 println메서드를 → Logging(자동차 블랙박스처럼)가능\n몰라도 문제는 없지만 번거로운 절차들을 자동화할 수 있어서 유용하다\n설치\n\nbuild.gradle의 dependencies 가 중요한데, 우리가 설치했던 내용들이 여기 다 나온다.\ndependencies에 lombok이라는 것을 추가해주자\n\n//롬복 추가\ncompileOnly &#039;org.projectlombok:lombok&#039;\nannotationProcessor &#039;org.projectlombok:lombok&#039;\n\n\n우측 위에 load gradle changes 코끼리버튼을 누른다\n\n\n플러그인도 설치하자 - lombok\n\n\n어노테이션 설치 활성화\n\n\n\n\n여기까지가 lombok 설치다. 원래는 맨처럼 io 때 해야하지만, 이렇게 나중에 해도돼\n도움말-액션찾기-플러그인에서 잘 설치되었는지 확인도 할 수 있어\n리팩토링\n잘 설치했으면,\n@AllArgsConstructor\n@ToString\n이런걸 dto같은데 넣어주면된다\n로깅 @Slf4j\n로깅은 블랙박스같은 느낌이다. 매순간의 영상을 다 기록하듯이, 내가 확인하고싶은 서버의 사건들을 모두 기록해둘 수 있는 기능이라고 볼 수 있다.\n@Controller\n@Slf4j //로깅을 위한 골뱅이(어노테이션) simple loging for 4 java\npublic class ArticleController {\n \n    @PostMapping(&quot;/articles/create&quot;)\n    public String createArticle(ArticleForm form){\n        //System.out.println(form.toString()); 로깅 기능으로 대체해보자\n        log.info(form.toString());\n \n        return &quot;&quot;;\n    }\n}\n위처럼 slf4j를 이용하면, System.out.println()이 아니라,\nlog.info(대상)을 쓸 수 있다"},"Spring-boot/MVC-역할과-실행-흐름":{"slug":"Spring-boot/MVC-역할과-실행-흐름","filePath":"Spring boot/MVC 역할과 실행 흐름.md","title":"MVC 역할과 실행 흐름","links":[],"tags":[],"content":"목표: 뷰템플릿 페이지가 출력되기까지 mvc역할과 실행흐름이 뭘까?\n서버에서는 모델, 뷰, 컨트롤러가 유기적으로 마구마구 동작하고있다\n컨트롤러가 GetMapping()을 이용해 주문(요청)받고,\n해당 메서드가 리턴값을 통해 view페이지를 보여주더라.\n여기서 view페이지에 변수가 등장하는데, 여기까지 도달하기위해 model을 거쳐야하더라.\n변수는 model을 통해 등록하니까말이야. !\n같은 방법으로 한번 더 해봤어.\n@Controller\npublic class FirstController {\n \n    @GetMapping(&quot;/hi&quot;)\n    public String niceToMeetYou(Model model){\n        model.addAttribute( &quot;username&quot;,&quot;혜경&quot; );\n        return &quot;greetings&quot;; // templates안의 greetings.mustache를 브라우저로 전송해라.\n    }\n \n    @GetMapping(&quot;/bye&quot;)\n    public String seeYouNext(Model model){\n        model.addAttribute(&quot;nickname&quot;, &quot;홍길동&quot;);\n        return &quot;goodbye&quot;;\n    }\n \n}\n "},"Spring-boot/ObjectMapper":{"slug":"Spring-boot/ObjectMapper","filePath":"Spring boot/ObjectMapper.md","title":"ObjectMapper","links":[],"tags":[],"content":"Json을 자바 객체로 변환하거나 자바 객체를 json으로 변환해준다\n객체를 json으로\nObjectMapper objectMapper = new ObjectMapper();\n \nString json = objectMapper.writeValueAsString(burger);\n여기서  burger는 미리 만들어둔 객체이다\n저 객체안의 내용을 json으로 반환해준다\njson을 좀 더 예쁘게 보고싶다면\nJsonNode jsonNode = objectMapper.readTree(json);\nSystem.out.println(jsonNode.toPrettyString);\n\njson을 객체로\nObjectMapper objectMapper = new ObjectMapper(); // 준비\n \nBurger burger = objectMapper.readValue(json, Burger.class);\n이와같이 json을 가지고 어떤 클래스타입으로 변환할건지 맞춰주면 정확히 그 객체로 바꾸어준다\n\njson을 직접 만들기\nObjectNode objectNode = objectMapper.createObjectNode();\nobjectNode.put(&quot;name&quot;, &quot;맥도날드 슈비버거&quot;);\nobjectNode.put(&quot;price&quot;, 5500);\n위와같이 하면 내가 원하는 것만 만들수가 있고. 배열도 넣을 수가 있다\nArrayNode arrayNode = objectMapper.createArrayNode();\narrayNode.add(&quot;통새우 패티&quot;);\narrayNode.add(&quot;순쇠고기 패티&quot;);\narrayNode.add(&quot;토마토&quot;);\n \nobjectNode.set(&quot;ingredients&quot;, arrayNode);\n \nString json = objectNode.toString();    "},"Spring-boot/db테이블과-sql":{"slug":"Spring-boot/db테이블과-sql","filePath":"Spring boot/db테이블과 sql.md","title":"db테이블과 sql","links":[],"tags":[],"content":"저장된 데이터를 드디어 db에서 확인해볼까?\n\ndb에서 확인하려면 먼저 접근설정을 해야해\n\n/Users/yunhyegyeong/Developer/firstproject/src/main/resources/application.properties\n#h2 DB, 웹 콘솔 접근 허용\nspring.h2.console.enavled=true;\n\nlocalhost:8080/h2-console/에서 확인할 수 있어\n\n\n\n데이터를 더미로 여러개 만드는 방법\n/Users/yunhyegyeong/Developer/firstproject/src/main/resources/data.sql"},"Spring-boot/spring-boot-project":{"slug":"Spring-boot/spring-boot-project","filePath":"Spring boot/spring boot project.md","title":"spring boot project","links":[],"tags":[],"content":"\n기본적으로 세팅된 환경아래, resources/static폴더에 hello.html을 넣고 서버를 돌리면, localhost:8080/hello.html으로 바로 접근도 가능하다\n\n\ntemplates에 view페이지 만들기\n컨트롤러 선언 @Controller\n뷰 페이지를 반환하는 메서드 선언  @GetMapping으로 라우팅\n변수를 넘길 수있도록 Model부르기.\n"},"Spring-boot/view-templates--and--MVC":{"slug":"Spring-boot/view-templates--and--MVC","filePath":"Spring boot/view templates & MVC.md","title":"view templates & MVC","links":[],"tags":[],"content":"mvc패턴을 활용한 템플릿 페이지를 만드는 것이 이번 챕터의 목표.\n자바는 다 정해져있어. 다. 전부.\n웹페이지에 변수를 허용하는 뷰 템플릿.\n뷰템플릿: 화면을 담당하는 기술. 웹페이지를 하나의 틀로 만들고, 변수의 값에 따라서 수많은 페이지로 바뀔 수 있다. controller(처리과정 담당/ 어떻게 오면..뭐 하고…)와 model(값, 데이터베이스 담당영역)이라는 동료가 있어.\n\n뷰템플릿이 어디있을까?\n\n/Users/yunhyegyeong/Developer/firstproject/src/main/resources/templates\n\ngreetings.mustach를 이 폴더에다가 만들면되는데, 그전에 도움말-액션찾기에서 plugins를 입력하고 mustache를 설치를해. 그리고나서 다시 만들면돼.\n\nmustach가 뭐냐고? 그냥 html을 다른이름으로 부른다고 생각해도돼\ndoc 하고 tab\n\n\n자!!! 이제 라우팅을 거는거야(컨트롤러) - 규정한 위치가 있어\ncom.example.firstproject 폴더에 package추가\n새로생긴 폴더 내부에 FirstController라는 Java 클래스 만들자고.\n\n\n일반적으로 블라블라 컨트롤러라고 많이 만들거든.(관례야)\n\n자 이제, 아까만든 mustache랑 연결해줄거야. 잘 봐야돼.\n먼저 어노테이션으로 @Controller라는 것을 명시해.\n\n@Controller\npublic class FirstController {\n    public String niceToMeetYou(){\n        return &quot;greetings&quot;; // templates안의 greetings.mustache를 브라우저로 전송해라.\n    }\n}\n\n문자열이 아니야. 주석에 적힌것처럼 templates/greetings.mustache를 부르는 메서드를 만들어준거야.\n\n\n끝이아니야. 이제 라우팅을 걸어야지!\n\npackage com.example.firstproject.controller;\n \nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@Controller\npublic class FirstController {\n    \n    @GetMapping(&quot;/hi&quot;)\n    public String niceToMeetYou(){\n        return &quot;greetings&quot;; // templates안의 greetings.mustache를 브라우저로 전송해라.\n    }\n    \n}\n\n다 되었으면 이제 재시작을 무조건해야해! 이제 hi로 접속하면 잘 나올거야.\n별 의미가 없어보이냐? 그러면 변수를 한번 이용해보자고. mustache를 바꿔버리자.\n\n&lt;body&gt;\n    &lt;h1&gt;{{username}}}님, 반갑습니다.&lt;/h1&gt;\n&lt;/body&gt;\n\n오, 이제 모델을 사용해야돼. 어디있냐고? 컨트롤러에서 받아와야해.\n\npackage com.example.firstproject.controller;\n \nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n//이게 컨트롤러\n@Controller\npublic class FirstController {\n \n    @GetMapping(&quot;/hi&quot;)                  //요아래 모델\n    public String niceToMeetYou(Model model){\n        model.addAttribute( &quot;username&quot;,&quot;혜경&quot; );\n        \n        //이게 뷰템플릿 부르기\n        return &quot;greetings&quot;; // templates안의 greetings.mustache를 브라우저로 전송해라.\n    }\n \n}\n \n\nModel model을 인자로 받을라고 하니까 빨간색이 뜨더라고. 그러면 눌러서 그 프레임워크를 불러오겠다고 지정을 해주면 돼.\n\n"},"Spring-boot/데이터생성-with-JPA":{"slug":"Spring-boot/데이터생성-with-JPA","filePath":"Spring boot/데이터생성 with JPA.md","title":"데이터생성 with JPA","links":[],"tags":[],"content":"JPA를 이용해 데이터베이스를 생성하자\n자바를 모르는 db에게 설명해야한다\n\nentity와 repository가 필요하다\n서버에서 db로 넘길수 있도록!.\nentity: 규격화된 데이터\n\n이 과정을 통해야만 데이터베이스에 담을 수 있다.\n\ndto를 entity로 변환\nentity를 repository로 변환\ndatabase로 쌓기\n\n(2번부터 3번으로 가게 해주는 애가 JPA)\n\n\n엔티티 패키지를 나의 프로젝트 메인패키지 안에 만들고\n/Users/yunhyegyeong/Developer/firstproject/src/main/java/com/example/firstproject/entity/Article.java\n\n\n그안에 클래스를 만들어\n\n클래스 내부에서는 어노테이션으로 Entity라는 것을 적어줘야해\n\n\n\n컨트롤러 내부에서는 두가지 단계를 이루어야해\n\n\ndto 를 반환해서  entity 를 만든다\n\ndto에게 toEntity()라는 메서드가 있어야해\n\n public Article toEntity() {\n        return new Article(null, title, content);\n }\n\n\nentity 안에 있는 아이의 모습 ㅜㅜㅜ\npackage com.example.firstproject.entity;\n \nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.Id;\n \n@Entity //이래먀만 db가 해당 객체를 인식할 수 있다. 아래 클래스로 테이블을 만들겠다 라는 의미\npublic class Article {\n \n    //private Long id; //구분하기위한 대표값(기본키)\n    @Id\n    @GeneratedValue\n    private Long id;\n \n    @Column //db에서 관리하는 테이블 쪽에 연결될 수 있도록\n    private String title;\n \n    @Column\n    private String content;\n \n    public Article(Long id, String title, String content) {\n        this.id = id;\n        this.title = title;\n        this.content = content;\n    }\n \n    @Override\n    public String toString() {\n        return &quot;Article{&quot; +\n                &quot;id=&quot; + id +\n                &quot;, title=&#039;&quot; + title + &#039;\\&#039;&#039; +\n                &quot;, content=&#039;&quot; + content + &#039;\\&#039;&#039; +\n                &#039;}&#039;;\n    }\n}\n \n\n\n\n\nrepository에게 entity를 db안에 저장하게 한다\n\n\n\nrepository 패키지를 만든다\n그 안에 인터페이스로 하나를 새롭게 만든다 ArticleRepository\n내부 내용으로 extends CrudRepository&lt;a,b&gt;{\na에는 관리대상 entity, b는 관리대상 entity에서 대표값의 타입\n그래서 우리는 &lt;Article, Long&gt; 이 된거다\n\n @PostMapping(&quot;/articles/create&quot;)\n    public String createArticle(ArticleForm form){\n        System.out.println(form.toString());\n \n        //1. dto를 변환 entity!\n        Article article = form.toEntity();\n        System.out.println(article.toString());\n \n        //2. repository에게 entity를 db안에 저장하게 함\n        Article saved = articleRepository.save(article);\n        System.out.println(saved.toString());\n        return &quot;&quot;;\n    }"},"Spring-boot/링크와-다이렉트":{"slug":"Spring-boot/링크와-다이렉트","filePath":"Spring boot/링크와 다이렉트.md","title":"링크와 다이렉트","links":[],"tags":[],"content":"페이지간에서 자연스럽게 이동해볼까?\n시작점: 목록페이지\n\n상세페이지로 이동(edit/delete)\n새 글 페이지로 이동(submit)\n\n\n지금까지 만든 서비스의 문제가 뭘까?\n\n아티클 목록페이지에서 새글을 작성하기위한 링크가 없어서 직접  new페이지에 들어가야했다\nnew페이지에서 뒤로가기 버튼이 없다 -즉, 페이지들의 연결고리가 없다\n\n새 글 작성 링크만들기\n\n\n일단 필요한 mustache페이지에다가 버튼들을 만들어.\n\n\n버튼을 만들어서 연결은했는데, 특히나 create페이지가 문제네?\n해당 페이지에서는 글을 작성한 후에 작성한 글의 view페이지로 이동했으면 좋겠거든\n\n\ngetId를 가지고와서 해당 페이지로 이동하게끔 postmapping을 수정하자\n @PostMapping(&quot;/articles/create&quot;)\n    public String createArticle(ArticleForm form){\n        \n \n        //2. repository에게 entity를 db안에 저장하게 함\n        Article saved = articleRepository.save(article);\n        //System.out.println(saved.toString());\n        log.info(saved.toString());\n \n        return &quot;redirect:/articles/&quot; + saved.getId(); //&lt;-------이거\n    }\n\n\ngetId를 못가지고와….. 그럴땐 게터를 추가해야지 엔티티에\n@Entity //이래먀만 db가 해당 객체를 인식할 수 있다.\n@AllArgsConstructor\n@NoArgsConstructor // 디폴트 생성자를 추가함\n@ToString\n@Getter\npublic class Article {\n \n    //private Long id; //구분하기위한 대표값(기본키)\n    @Id\n    @GeneratedValue\n    private Long id;\n \n    @Column //db에서 관리하는 테이블 쪽에 연결될 수 있도록\n    private String title;\n \n    @Column\n    private String content;\n\n"},"Spring-boot/빌드-후-간단한-텍스트-띄우기":{"slug":"Spring-boot/빌드-후-간단한-텍스트-띄우기","filePath":"Spring boot/빌드 후 간단한 텍스트 띄우기.md","title":"빌드 후 간단한 텍스트 띄우기","links":[],"tags":[],"content":"빌드까지 되었다면 hello world를 띄워볼까?\n아무것도 안하고 src폴더의main폴더의 java폴도의com.example.demo 폴더의\n/Users/yunhyegyeong/Developer/firstproject/src/main/java/com/example/firstproject/FirstprojectApplication.java\n클래스를 들어가서 실행을시켜보니\n\n잘나오네.\n만든게 없으니까 당연히 에러페이지가 뜨겠지.\n\n얘네는 tomcat을 쓰거든. 웹서버로. 근데 그거도 알아서 다 설치가 된거야.\n아래쪽에 뺑뺑이가 도는건 당연한거야. 시스템 가동중이라는 뜻이거든\nresourse폴더가 있는데, static은 노드의 static같아.\n거기에 templates는 pug을 대신하는 mustach를 넣겠지\nstatic폴더에 hello.html을 만들거야. 정적파일 띄울라고!!!!!!!!!!!!!\n저장한 다음에 다시한번 서버를 재시작해야해.\n이제는 localhost:8080/hello.html에 접속하면 잘뜨지!\n\n\n웹서비스의 동작원리\n헬로월드가 출력되는 과정을 한번 알아볼까?\n웹서비스는 서버와 클라이언트의 요청과 응답으로 이루어지지.\nhello world 도 그랬어\n\n\n브라우저를 띄워서  localhost:8080에 접속한다\n\n\n안된다고 뜬다. 왜냐면 서버를 안켰으니까\n\n\n프로젝트를 오픈하고 실행을 한다(기본패키지 내부의 메인메서드를 찾아서)\n\n\n실행하면 tomcat 이 8080에서 실행된다는 메시지가 있을것이다 바로 이거야.\n\n\n이러면 서버를 통해서 브라우저가 해당 내용을 볼 수 있게 되는거지. (요청과 응답이 일어났구나!!🤩)\n\n\n우리집에서 8080방에서 돌아가고있는 서버에서 hello.html이라는 파일을 요청하면?\n\n\nstatic폴더에서 hello.html을 찾아서 응답으로 던져주게 되는거다\n\n"},"Spring-boot/초기-개발-환경-세팅하기":{"slug":"Spring-boot/초기-개발-환경-세팅하기","filePath":"Spring boot/초기 개발 환경 세팅하기.md","title":"초기 개발 환경 세팅하기","links":[],"tags":[],"content":"www.youtube.com/watch\n\n개발환경 갖추기 1 - jdk\n&lt;JDK설치하기 - 자바 개발자들이 자바 프로그램을 활용하기위해 설치해야하는 것&gt;\n윈도우\n\n명령프롬프트 실행 후 , java -version으로 설치 확인\nAdoptOpenJdk을 구글에서 검색한다\n11버전을 사용해라(영상에서는 8버전쓰지만;) latest release\n실행하고 next….next…install…\n명령프롬프트: java -version 으로 확인(명령프롬프트 껐다켜)\n\n맥북\n\nhomebrew 설치 후 java -version으로 버전확인\nhomebrew jdk설치 라고 검색해봐.\n\n개발환경 갖추기 2 - intellij\nbrew search intellij\nce버전이 학습자 버전(community edition)\nbrew install —cask intellij-idea-ce\n개발환경 갖추기 3 - 스프링부트 만들기\nstart.spring.io/\n위 사이트에서 주소창 우측에 다운로드 받아라. - 이걸 사용하면 간편하게 도구 세팅이 가능하다\n인텔리제이의 유료버전은 이 화면을 가지고있지만, 커뮤니티 버전은 이걸 수동으로 따로해야한다 - 괜찮아. 하면돼\n\nGradle Project 선택\n패키징은 jar선택\n아래 java는 내 버전과 같은거 선택\ngroup은 프로젝트 위치(도메인으로 이름을 만들잖아)\nartifact가 프로젝트명\n우측에 있는 dependentcies 는 요리도구 같은거다\n\nspring web : 백엔드단을 구성해야하니까 spring web설치\nh2 database : db의 여러종류중에 h2를 사용하는 것\nmustache: pug가지고 렌더링하는것처럼 자바의 렌더링도구\nSpring data JPA: 스프링하고 데이터베이스를 연결하는 그 부분\n\n\ngenerate를이용하면 간편하게 프로젝트를 생성할 수 있다\nzip파일로 다운로드 받게되고, node init한거마냥 필요한 패키지가 수루루루룩 설치된다! WOW!\n이제 인텔리제이에서 프로젝트 파일을 열기만 하면 끝!\n시간이 엄~~~청 오래걸린다\n\n이렇게 자동으로 완성해주는것들을 보이드템플릿이라고 말한다"},"git/Start-Git":{"slug":"git/Start-Git","filePath":"git/Start Git.md","title":"Start Git","links":[],"tags":[],"content":"git init\n버전관리를 시작하겠다고 선언\n\ngit status\n버전관리가 되고있는 내용들을 볼 수 있다\n여기서 어떤파일들이 관리되고 있는지 확인가능\n\ngit add\n내가 추적하고싶은 파일을 git에게 알려준다.\n프로젝트를 하다보면, 꼭 관리해야하는 파일만을 관리하는것이 좋다\n그렇기때문에 관리하려는 파일을 정확히 체크해서 알려주는것이 좋다\n왜  add를 꼭 해야할까?\n여러 코드를 수정하다보면 커밋하는 시기를 놓칠수가 없다.\n커밋하나는 하나의 작업을 가지고있는게 이상적이지만, 커밋시기를 놓치면 그러기가 어렵다\n그럴때 우리는  add를 이용해서 딱 내가 원하는 것만 골라서 커밋할 수 있다는 장점이있다\ngit status에서 초록색으로 나오는 파일만 커밋이 될 것이라고 알려주는 것이다.\n선택적인 커밋이 가능하다\nstage area\nadd 해놓아서 커밋 대기에 있는 파일들은 stage area에 들어가게된다. 이를 커밋대기상태라고 할 수 있다.\n커밋 되는 파일이 저장되는 곳이 repository이다.(나중에 추가학습할 것이다)\n\n버전: 의미있는 변화, 단위 작업이 완결된 상태\n\nUser Setting\ngit config --global user.name yoondd \ngot config --global user.email yoondd@kakao.com\n\n\n위 내용은 딱 한번만 하면된다.\n다른사람에게 누가 작업했는지를 알려주는 것.\n\ngit commit\n정보를 알려준다.\n현재 버전의 메시지를 가장 위쪽에다가 적어주면된다.\n왜 바뀌었는지, 어떤것들이 변경되었는지의 커밋메시지를 입력해준다.\n→ 이걸 쓰면 바로 버전을 만들게 되는 것이다\ngit commit -a\n\n위 명령어를 치면 자동으로 add 기능까지 할 수 있다.\ncommit이 가지고 있는 주요한 정보들\n\n이전 커밋이 누가인가. 부모를 가리키는 parent값.\n커밋이 일어난 시점에 우리의 작업 디렉토리에 있는 파일들의 이름과 파일들이 가지고 있는 내용이 무엇인가\n즉, 버전이 만들어진 시점에 프로젝트 폴더의 상태를 확인할 수 있다 - 이를 스냅샷이라고하고, 트리를 통해 스냅샷을 확인할 수 있다.\n\n\ngit log\n어떤 변화가 일어났는지 그 로그를 확인할 수 있다.\n역사를 확인하는 방법이다\n\n버전을 만들면, 이제 무얼 할 수 있을까? 효용이 무얼까.\n\n차이점을 알 수 있다\n과거로 돌아갈 수가 있다.\n\n1. 차이점을 확인할 수 있다\ngit log명령을 이용해서 커밋메시지를 포함한 역사들을 확인할 수 있다.\ngit log -p 명령어를 이용하면 각각의 커밋사이의 소스의 수정사항을 보여준다.\ndiff --git a/f1.txt b/f1.txt\nindex 1ef490d..56e7ceb 100644\n--- a/f1.txt\n+++ b/f1.txt\n@@ -1 +1 @@\n-source: 2\n+f1.txt: 4\n\n이런식으로 나온다. 자세히보니, ---a라고 적힌건 이전파일, +++b라고 적힌건 새로운 파일이라고 볼 수 있다\n변화가 어떤게 일어났는지 정확하게 확인할 수 있게 되는 것이다\ngit diff\n각각의 커밋은 고유의 아이디가 있다. 복잡하게 생긴 엄청 긴 값. 그게바로 고유한 값이다\ngit commit &lt;고유한 아이디&gt;를 적어주면 해당내용이 보인다.\ngit diff 9fe6fc69ea2b55968e329aefe92d33fbd1e422ad..92ae35651e6ffe2621adc69c564c02420ca85ef0\n\n위와같이 정확하게 어떤 커밋들 사이의 차이를 확인할건지를 정확히 입력할 수도 있다\n간단히 문법을 정리하면 git diff &lt;commit id&gt;..&lt;commit id&gt;이다.\ngit diff\n\n사실 그냥 이렇게만 입력했어도, 내가 커밋하기전에 내가 작업한 내용을 먼저 확인해낼 수 있다.\n이는 마지막으로 리뷰할 수 있는 기회가 된다. 여기에는 아직  add 하지 않은 내용이 나온다.\n2. 과거로 돌아갈 수 있다\n커밋을 취소하는 명령이라고 볼 수 있는데 주의를 많이 해야한다.\n돌아가는 크게 두가지 방법이 있다\n\nreset\nrevert\n\ngit reset\ngit reset dadbd454013eed7f3587ba1b30bf25f0b11d9c8a --hard\n\n해당내용의 커밋으로 돌아가게된다. 버전 두개를 버린 것 처럼 보이지만 사실은 남아있다.\n복구할수는 있지만 어려운 내용이니까 나중으로 넘기자.\n일단은 버전을 버리고 저 커밋id로 돌아갈 수 있다.\n그런데 여기서 너무나 중요한 내용.\n절대로 공유한 파일을 reset하지말아라\n원격저장소를 배우고 협업을 할 때, 공유를 할 수 있는데 그때는 절대로 reset을 해서는 안된다\n저 위에서 나오는  hard는 굉장히 위험하지만, 단순하고 강력한 방법이기는 하다.\n나중에 옵션을 좀 더 알아보자\ngit revert\n커밋을 취소하는건 맞지만, 커밋을 휙 날려보내는 것이 아니라, 해당 커밋을 취소하면서 새 커밋을 만드는 것이라고 볼 수 있다. 현재는 그냥 그런줄만 알자."},"git/git의-원리":{"slug":"git/git의-원리","filePath":"git/git의 원리.md","title":"git의 원리","links":[],"tags":[],"content":"깃의 내부를 분석해보자.\nWorking directory - index, staging area, cache - repository"},"git/배포자동화를-위한-deploy.yml":{"slug":"git/배포자동화를-위한-deploy.yml","filePath":"git/배포자동화를 위한 deploy.yml.md","title":"배포자동화를 위한 deploy.yml","links":[],"tags":[],"content":"deploy.yml 파일이란?\n이 파일은 GitHub Actions와 같은 CI/CD(Continuous Integration/Continuous Deployment) 도구에서 워크플로우를 정의하는 데 사용되는 것으로 주로 프로젝트의 빌드, 테스트, 배포 과정을 자동화하며, 일반적으로 .github/workflows 디렉토리에 위치하고있다.\n주요 역할\n\n\n배포 자동화\n코드 변경사항이 발생할 때마다 배포 프로세스를 자동으로 실행해준다. 이를 통해서 반복적인 수작업을 줄이고 일관된 배포를 보장할 수 있다.\n\n\n작업 트리거 설정\n특정 이벤트가 발생했을 때 워크플로우를 실행할 수 있도록 설정한다. 예를 들자면,  main브랜치에 변경이 생길 때 배포 프로세스를 실행할 수 있다\n\n\n배포 환경 설정\n배포에 필요한 환경을 구성할 수 있다. 자바나 node js 설정, 도커 이미지 생성 등을 포함해서 여러가지 환경 설정을 해낼 수 있다. 예를들어서 node js 환경을 구성한다면,\n\n\njobs: \n\tdeploy: \n\t\truns-on: ubuntu-latest \n\t\tsteps: \n\t\t\t- name: Set up Node.js \n\t\t\t  uses: actions/setup-node@v2 \n\t\t\t  with: node-version: &#039;16&#039;\n\n이런식으로 구성할 수 있다.\n\n\n외부 서비스와의 통합\nAWS S3, CodeDeploy, Docker등과 통합해 애플리케이션을 배포할 수 있다\n\n\n보안 기능\nAPI키나 비밀번호 처럼 민감한 정보들은 따로 관리해서 ${{secrets.AWS_ACCESS_KEY_ID}} 처럼 따로 불러올 수 있다. 민감한 정보가 노출되면 위험하니까!\n\n\n빌드나 테스트 단계를 지원하기도 한다\n\n\n덧붙이는 이야기\nquartz를 이용해서 블로그를 만들었는데, localhost에서는 정상작동했지만 실제 git에  push했을때는 정상적으로 확인되지않아 엄청 머리가 아팠다. 이런 개념이 제대로 잡히지않은 나로써는 deploy파일이 있는데 왜 안돼!!라면서 혼자 머리아팠다.\n이 고생을 나의 뮤즈의 도움을 받아 해결했다. 역시 나의 뮤즈는 보자마자 뭐가 문제인지 바로 처리해주었다… 👍🏻\n말도 안되는 나의 수정 전 deploy.yml\nname: Deploy Quartz site to GitHub Pages\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  id-token: write\n  pages: write\n  contents: write\n\njobs:\n  build:\n    environment:\n      name: github-pages\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: &#039;20&#039; # 또는 Quartz가 지원하는 버전\n      - run: npm ci\n      - run: npx quartz build\n      - run: find ./public -type l -delete # 필요시만 사용\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./public\n\nmuse 수정작\nname: Deploy Quartz site to GitHub Pages\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\nconcurrency:\n  group: &quot;pages&quot;\n  cancel-in-progress: false\n\njobs:\n  build:\n    runs-on: ubuntu-22.04\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          fetch-depth: 0 # Fetch all history for git info\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 22\n      - name: Install Dependencies\n        run: npm ci\n      - name: Build Quartz\n        run: npx quartz build\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v3\n        with:\n          path: public\n\n  deploy:\n    needs: build\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n\n\n나는 왜 build만 있고 deploy는 넣지않은거지…"},"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":"윤혜경\nWelcome to my BLOG\n이 곳은 제가 공부한 내용들을 차곡차곡 담아놓은 곳입니다.\n앞으로 걸어갈 길에 도움이 되기를 바라는 마음입니다."},"obsidian/옵시디안에서-이미지-사용하기---Imgur":{"slug":"obsidian/옵시디안에서-이미지-사용하기---Imgur","filePath":"obsidian/옵시디안에서 이미지 사용하기 - Imgur.md","title":"옵시디안에서 이미지 사용하기 - Imgur","links":[],"tags":[],"content":"옵시디안에서 이미지를 사용하려고하니까 자꾸 로컬에 이미지가 저장이되어서 불편했다.\n찾아보니 Imgur이라는 플러그인을 사용해서 이미지를 관리할 수 있다고 했다.\n\n옵시디안에서 플러그인 설치하기 Obsidian Imgur Plugin\n옵시디안 설정 -  Imgur 에서 Authenticated Upload을 선택한다\nImgur사이트에서 계정을 만들고 api.imgur.com/oauth2/addclient 페이지에서 새로운 애플리케이션을 만들어 Client Id를 받는다\n플러그인 설정에 붙여넣기하고 연동한다.\n\n이제는 그냥 이미지를 캡쳐떠서 넣기만 하면 자동으로  imgur 사이트에 업로드가 된다."},"open-api/GCP":{"slug":"open-api/GCP","filePath":"open api/GCP.md","title":"GCP","links":[],"tags":[],"content":"\n\n콘솔에서 사용해보기\ncloud.google.com/free+%7C+BKWS+-+EXA+%7C+Txt+-GCP-General-core+brand-main-KWID_43700077514871058-kwd-87853815&amp;userloc_9214122-network_g&amp;utm_term=KW_gcp&amp;gad_source=1&amp;gclid=Cj0KCQjw2N2_BhCAARIsAK4pEkW4rf_1TBNHbh6EFZlosOwhEnA-s2KZa2HsUU1nwH_EqyddiBSyxUwaAiLQEALw_wcB&amp;gclsrc=aw.ds&amp;authuser=1\n\n\n클라우드 쉘을 사용할 수 있어야한다. (우측 상단)\n\n\n왼쪽에 햄버거 바에서 클릭클릭하면서 쓰는 방법으로도 쓸 수 있다\n\n\ngcp에서 sql공간을 하나 얻어서 테이블을 만들 것이다.\n환경이 다를 수있으니까 gcp스토리지에 우리가 도커파일을 만들어서 올리고, 그러면 api가 하나 떨어진다.\n그걸 우리 서버파일에다가 올린다. 이걸 진행하면 gcp와 우리의 컴퓨터가 서로 교류할 수 있게된다.\n\n\nsql 인스턴스 만들기\n\n\n\nEnterprise 우측을 누른다.  pro말고.\n샌드박스 선택(제일 저려한 것)\nmysql 8.0\nroot/ 비번(복잡성 선택 후 복잡하게)\n리전: 아이오와 --- 실제 서버가 있는 위치/ 물가 싼나라가 최고다\n머신 구성 CPU 1개\n데이터 캐시는 사용해제로 그대로 유지하기\n저장용량은 HDD로 변경하고 10GB 유지\n연결은 비공개와 공개 둘다 해두기\n네트워크추가하기. any(이름 아무거나해도 상관없음) / 누구나 접근가능하도록 0.0.0.0/0으로 일단설정\n데이터보호는 자동백없이 되지않게 설정하기!\n\n\n\n기본인스턴스 사이드바 ‘연결’에서 나오는 공개 IP주소가 나의 sql로 들어올 주소라고 보면 된다.\n\n\n사이드바에서 사용자를 확인해보고, 데이터베이스로 들어가서 데이터베이스를 만든다\n우리는 root라는 데이터베이스를 만들었다\n\n\n사용자 메뉴로 가서 root의 비밀번호를 변경했다\n내가 사용하는 비밀번호 중에 최고 난이도의 비밀번호로…🤨\n\n"},"open-api/api를-쓰려면":{"slug":"open-api/api를-쓰려면","filePath":"open api/api를 쓰려면.md","title":"api를 쓰려면","links":[],"tags":[],"content":"\n인증파일 설치 요구를 한다\napi-key발행한다 - 사용자를 구분하기위한  api key\napi를 사용한다\n\n이같이 이루어지는 이유는 api서버 아무나한테 기능을 줄 수는 없으니까. 인증된 사용자에게만 제공해야지."},"open-api/open-weather":{"slug":"open-api/open-weather","filePath":"open api/open weather.md","title":"open weather","links":[],"tags":[],"content":"openweathermap.org/current\n어떻게 써야하는지 자세히 나와있다.\n2025.04.08.\n오늘 처음으로 회원가입을 했고, 간단하게 키를 발급받고 gpt를 사용해서 도움받아 구현했다.\nconst fetchWeather = async (city) =&gt; {\n    const url = `api.openweathermap.org/data/2.5/weather${city}&amp;units=metric&amp;appid=${apikey}`;\n  \n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Error: ${response.status}`);\n      }\n      const data = await response.json();\n \n      // 날씨 아이콘.\n      const iconCode = data.weather[0].icon;\n      const iconUrl = `openweathermap.org/img/wn/${iconCode}@2x.png`;\n      const weatherIconElement = document.getElementById(&#039;weatherIcon&#039;);\n      weatherIconElement.src = iconUrl;\n \n      // 온도.\n      const temp = data.main.temp;\n      const temp_Element = document.getElementById(&#039;temp&#039;);\n      temp_Element.textContent = `${temp}°C`;\n \n      // 날씨 컨디션. \n      const weatherCondition = data.weather[0].main; \n      const conditionElement = document.getElementById(&#039;condition&#039;);\n      conditionElement.textContent = weatherCondition;\n      \n    } catch (error) {\n      console.error(error.message);\n    }\n  };\n  \n  // 사용 예시\n  fetchWeather(&#039;Suwon&#039;);\n  "},"open-api/챗GPT-활용-챗봇-만들기":{"slug":"open-api/챗GPT-활용-챗봇-만들기","filePath":"open api/챗GPT 활용 챗봇 만들기.md","title":"챗GPT 활용 챗봇 만들기","links":[],"tags":[],"content":"\n\nchat gpt 유료회원되기\n\n\nchat gpt 사이트에서 Explore GPTs 클릭하기\n다른 사람들의 챗봇을 많이 확인할 수 있다.\n\n\n우측 상단 create클릭해서 new GPT만들기\n\n\nGPT builder에게 어떤 챗봇을 만들고 싶은지 적어두기\n\n\n챗봇이 어떻게 만들어졌는지 확인하려면 Configure를 누른다.\n\n"},"react/Framer-Motion":{"slug":"react/Framer-Motion","filePath":"react/Framer Motion.md","title":"Framer Motion","links":[],"tags":[],"content":"리액트에서 애니메이션을 간단하게 사용하고 싶을때 좋은 라이브러리이다.\n웹 애니메이션과 드래그, 탭, 호버 등의 기능을 구현할 수 있다.\n주요 특징\n\nReact와의 완벽한 통합: JSX 태그에 motion.을 붙여 애니메이션 요소를 생성.\n다양한 애니메이션 지원: 위치 이동, 크기 조정, 회전, 불투명도 변경 등.\n제스처 기반 인터랙션: 드래그, 호버, 탭과 같은 사용자 동작에 반응하는 애니메이션 구현.\n레이아웃 애니메이션: 컴포넌트 간의 자연스러운 전환 효과 제공.\n반복 및 딜레이 설정: 애니메이션 반복, 딜레이, 커스텀 트랜지션 가능.\nTypeScript 지원: 타입 안정성을 제공하여 개발 생산성 향상.\n\nimport { motion } from &#039;framer-motion&#039;;\n \n \n&lt;motion.div\n\t// 초기상태 선언\n\tinitial={{ opacity: 0, y: 70 }}\n\twhileInView={{ opacity: 1, y: 0 }}\n\ttransition={{ duration: 1.5, ease: &#039;easeOut&#039; }}\n\tviewport={{ once: true, amount: 0.4 }}\n\tclassName=&quot;fade-section&quot;\n&gt;\n&lt;div className=&quot;img-box&quot;&gt;\n\t&lt;img src={`${process.env.PUBLIC_URL}/images/img6.jpg`} alt=&quot;고양이&quot; /&gt;\n&lt;/div&gt;\n&lt;div className=&quot;text-box&quot;&gt;\n\t&lt;h2&gt;Cat, Cat, Cat!!!&lt;/h2&gt;\n\t&lt;h4&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Sed quia nam eum hic asperiores, voluptas libero illo ducimus odio eligendi nobis. Eligendi enim saepe quis molestiae facilis illum, eaque sint.&lt;/h4&gt;\n&lt;/div&gt;\n&lt;/motion.div&gt;\n이런식으로 사용했다.\n다양한 옵션들이 들어간다.\n스크롤대응도 가능한 것으로 보인다.\n자주 쓰는 위치/변형 관련 속성들\nx: 수평 이동\ny: 수직 이동\nscale: 크기 비율 ()… (아직 정리중이다…)"},"react/React-ClassName":{"slug":"react/React-ClassName","filePath":"react/React ClassName.md","title":"React ClassName","links":[],"tags":[],"content":"&lt;div className=&quot;home-container&quot;&gt;\n리액트에서 클래스네임을 지을 때,  중간에 하이픈을 쓰는 것은 순수 리액트라는 것을 전달할 수 있다."},"react/Start-React":{"slug":"react/Start-React","filePath":"react/Start React.md","title":"Start React","links":[],"tags":[],"content":"\n\nVS CODE 확장프로그램  - ES7\n\n\nnpm init하기\n\n\nnpx create-react-app &lt;나의프로젝트이름&gt;\nnpx가 아니라도 괜찮지만, 리액트가 원하는 설정을 빠르게 할 수 있어서 많은 사용자들이 npx를 이용한다.\n프로젝트 이름은 추후에 깃허브에 편하게 배포하기위해 간단하게 만들 수 있다\n나의 프로젝트: FRONT_CLASS &gt; class1\n\n\n리액트에 필요한 것들을 설치\n\n\nnpm install react-router-dom framer-motion axios react-icons\nreact-router-dom은 필수로 설치한다\n"},"react/react-컴포넌트-만들기":{"slug":"react/react-컴포넌트-만들기","filePath":"react/react 컴포넌트 만들기.md","title":"react 컴포넌트 만들기","links":[],"tags":[],"content":"이미지는 어디에 저장하는가?\n배포를 위해서 public폴더에 배포에 필요한 이미지를 담아야한다.\nreact는 public이 루트이니까. ( index.html이 public에 있잖아 )\npublic 안에 images 혹은 assets라는 폴더를 만들고 그 안에 넣는다.\n미리 설계하자\nsrc 폴더안에 두개의 폴더를 만든다. component, pages\n모든 페이지에 nav가 들어갈것이다.\n공통적으로 들어가는 컴포넌트는 component폴더에다가 넣어야겠다\npages에는 각각 들어가는 서브페이지에 나오는 컴포넌트를 넣을 것이다.\n확장자 jsx\n리액트가 가지고있는 고유기능을 사용하려면 jsx를 사용한다.\n이름 첫글자는 대문자를 사용하는게 규칙이다 ⇒ pages/Home.jsx\n컴포넌트 자동생성\nrafce를 눌러주면 자동으로 생성된다\nsrc쪽에 먼저 컴포넌트를 만들고 나중에 테스트를 해야만 오류가 나지않는다.\n\nRouter에 나오는 basename?\n깃허브에서 배포했을때 나의 레포지토리 이름을 넣어, 출발점을 알려주는 것이다\n\nApp.js안에 라우트걸기\nfunction App() {\n \nreturn (\n\t\n\t&lt;Router basename=&quot;/class1&quot;&gt;\n\t\t&lt;div&gt;\n\t\t\t&lt;Navbar /&gt;\n\t\t\t&lt;Routes&gt;\t\n\t\t\t\t&lt;Route path=&quot;/&quot; element={&lt;Home/&gt;}/&gt;\n\t\t\t\t&lt;Route path=&quot;/gallery&quot; element={&lt;Gallery/&gt;}/&gt;\n\t\t\t&lt;/Routes&gt;\n\t\t&lt;/div&gt;\n\t&lt;/Router&gt;\n \n);\n}\n리액트의 링크\na 태그를 쓰는 것이 아니라 link를 쓴다.\nimport { Link } from &#039;react-router-dom&#039;;\n \n&lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt;"},"react/useEffect":{"slug":"react/useEffect","filePath":"react/useEffect.md","title":"useEffect","links":[],"tags":[],"content":"선생님께 여쭤보았다. 언제 내가 useEffect를 사용해야겠구나. 생각하면되는건가?\n”실시간으로 받아오는 데이터가 필요할 때.”\n실시간으로 값이 계속 바뀌어야하는 정보가 있을 때, 대표적으로 API가 있지.\n그럴때 사용하는게 바로 useEffect다.\nAPI쓸 때는 useEffect를 쓴다. 이렇게만 이해하면 충분하다.\n상태변화를 의미하는 것으로 useState와 함께, 리액트에서의 꽃인 훅이다.\nQ. 그러면 실시간으로 받아오는 데이터가 여러개면 그때마다 useEffect를 여러개 만들어야하나요?\nA. 응. 그렇지. 하지만 그렇게까지 많이 사용하지는않아. 리액트 자체가 컴포넌트 기반이잖아. 그렇게 받아올게 많다면 당연히 컴포넌트로 분리해서 해당 컴포넌트 내에서 useEffect를 사용하지. 그러니까 하나의 컴포넌트에 거의 2개정도까지만 사용하는 편이야.\n이런 것들이 조금 더 발전한다면 redux가 된다."},"react/배포직전에404파일제작":{"slug":"react/배포직전에404파일제작","filePath":"react/배포직전에404파일제작.md","title":"배포직전에404파일제작","links":[],"tags":[],"content":""},"react/흐르는-슬라이드--and--scroll-대응-모션":{"slug":"react/흐르는-슬라이드--and--scroll-대응-모션","filePath":"react/흐르는 슬라이드 & scroll 대응 모션.md","title":"흐르는 슬라이드 & scroll 대응 모션","links":["react/Framer-Motion"],"tags":[],"content":"\n\npublic에서 data 폴더를 만든 후에 json파일을 만들었다\n\n\n갤러리 jsx에서 흐르는 이미지를 만들어보자.\n\n기본적으로 상태가 변화하기때문에 useEffect랑 useState는 필요하지\njson파일을 fetch로 들고와서 실시간으로 들고와서 배출해 낼것이다 - 공공 api는 걔네가 만든거 가져오는거고 지금은 내가 만든거 가져오는거고. 그러니까 useEffect를 사용해야지\n이제 json가져올거니까 async 함수 사용하자 const fetchImg = async () =&gt; {} 이렇게 쓰자. 그래야 await를 쓸 수 있지\n가져온다음에 순서대로 이미지를 끼워넣는다 (모자랄까봐 concat 사용)\n그리고 애니메이션은 css로 주셨음..\n\n\n\n스크롤이되면 올라오는건 frame motion을 이용해서 구현해보자. 라이브러리이기때문에 훨씬 수월하다\n\nimport { motion } from &#039;framer-motion&#039;;을 이용해서 일단 불러오자\n태그 이름이 div 가 아니라, motion.div이다.\n이부분은 다시 다른 페이지에서 정리해보자 — Framer Motion\n\n\n"},"sql/DBeaver":{"slug":"sql/DBeaver","filePath":"sql/DBeaver.md","title":"DBeaver","links":[],"tags":[],"content":"\n나는 공식웹사이트를 이용해서 다운로드 받았다.\n\n\n\nmysql선택하고 공개ip를 서버호스트로 사용\nserverhost : &lt;나의 공개 ip&gt;\ndatabase: root\nusername: root\npassword: &lt;나의패스워드&gt;\n\n\ntest connection해보기\n\n\nsql편집기 - 새창을 하나 띄우면 이제 여기에 명령어를 넣을 수 있다\n\n\n테이블 하나 만들기 -  ctrl+enter\n\n\nCREATE TABLE guest (\n\tid INT AUTO_INCREMENT PRIMARY KEY,\n\tname VARCHAR(100) NOT NULL,\n\tmessage TEXT NOT NULL,\n\tcreated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n)\n\n자료 넣고 확인해보기. 어렵지 않다.\n"},"sql/mysql/PREPARE--and--EXECUTE":{"slug":"sql/mysql/PREPARE--and--EXECUTE","filePath":"sql/mysql/PREPARE & EXECUTE.md","title":"PREPARE & EXECUTE","links":[],"tags":[],"content":"PREPARE\nSQL문의 미리 준비하는 단계를 말한다.\n쿼리의 구조가 고정되고, 실행했을 때 동적으로 값을 제공할 수 있는 자리표시자(?)를 사용할 수도 있다\nPREPARE happy FROM `SELECT * FROM users WHERE id = ?`;\n위 코드에서 happy는 sql문의 이름을 말한다.\nEXECUTE\n준비된 sql문을 실행하는 단계이다.\n여기서는 자리표시자로 지정해둔 곳에 값을 실제로 할당하여 처리한다\nSET @user_id = 1;\nEXECUTE happy USING @user_id;\n여기서 만든 변수를 사용하여 값을 할당했다."},"sql/mysql/View":{"slug":"sql/mysql/View","filePath":"sql/mysql/View.md","title":"View","links":[],"tags":[],"content":"뷰는 무엇인가?\n데이터베이스 개체 중 하나로, 테이블처럼 사용할 수 있는 개체다.\n하지만 테이블과는 다르게 뷰는 데이터를 가지고 있지는 않다.\n마치, 바탕화면 아이콘처럼 사용된다고 볼 수 있다.\n사용자는 진짜 테이블라고 생각하고 접근하고 조회하지만, 실제로는 테이블에서 가져온다는 의미다.\n뷰의 생성\n뷰는 하나의 테이블로 만든 단일뷰와 2개이상의 테이블과 연관된 복합뷰로 나뉜다.\nCREATE VIEW 뷰 이름\nAS\n\tSELECT 구문;\n다음과 같이 사용하면 된다. 여기서 뷰의 이름은 통상적으로 v_를 붙여서 사용한다.\n예를들면, v_member처럼 말이다.\n뷰의 조회\nSELECT * FROM v_member\n위와같이 그냥 모든 열을 확인할 수 있고,\nSELECT mem_name, addr FROM v_member\n\tWHERE addr IN (&#039;서울&#039;, &#039;경기&#039;);\n이 것처럼 필요한 열을 보거나 조건식을 넣을 수 도 있다.\n뷰의 목적\n\n\n보안에 도움이 된다\n원장을 열어주는 것이 아니기때문에 당연히 보안적으로 우수하다\n\n\n복잡한 SQL을 단순하게 만들 수 있다\n\n\n뷰 정보확인\n\nCREATE VIEW :  기존에 뷰가 있으면 오류 발생\nCREATE OR REPLACE VIEW : 기존에 뷰가 있어도 덮어쓰는 효과를 냄\n"},"sql/mysql/import-DB":{"slug":"sql/mysql/import-DB","filePath":"sql/mysql/import DB.md","title":"import DB","links":[],"tags":[],"content":"\nserver- data import 선택\nimport from self-contained file에서 내가 원하는 sql 파일 선택하기\ndefault target schema에서 내가 원하는 데이터베이스 선택하기\nstart import 선택하기\n\n그러면 내가 원하는 데이터를 내가 원하는 데이터베이스에 담을 수 있다.\ntables에 내가 만든 테이블들이 모두 담기고, views 같은 폴더가 별도로 있다."},"sql/mysql/workbench-강제종료문제":{"slug":"sql/mysql/workbench-강제종료문제","filePath":"sql/mysql/workbench 강제종료문제.md","title":"workbench 강제종료문제","links":[],"tags":[],"content":"계속 mysql Workbench가 강제종료되는 문제가 발생했다.\nbrew install mysql\n\n꽤 긴 시간에 걸쳐 mysql을 설치 한 후에\nbrew services start mysql\n\n위 명령어를 이용해 mysql을 실행시켰다\nmysql -u root\n\n루트 계정으로 접속하고나니 Workbench에서 접속이 가능해졌다.\n\n참고로, mysql을 끄는 것은\nbrew service stop mysql\n"},"sql/postgreSQL/postgreSQL-삭제하기":{"slug":"sql/postgreSQL/postgreSQL-삭제하기","filePath":"sql/postgreSQL/postgreSQL 삭제하기.md","title":"postgreSQL 삭제하기","links":[],"tags":[],"content":"공식사이트를 이용해서 설치한  postgreSQL을 삭제하려고한다.\n스프링부터 강의 영상에서 보고 그대로 설치했고, 설치당시에 비밀번호를 입력하라고하기에 잘 따라했는데 (초기 비밀번호는 postgres 였다) 자꾸 pgAdmin실행 시 비밀번호가 틀렸다는 안내메시지가 확인되었기 때문이다.\n몇번을 다시 깔고 설치하기를 반복했으나, 그 과정이 잦아서 남겨본다.\n슬프게도 앞으로도 수없이 반복해야할 수도 있기에말이다.\n참고로 버전은 17버전이다.\n\n\n서버 중지\n사실 켠적도 없어서 중지할것도 없지만, pgAdmin을 종료했다.\n\n\n터미널에서 삭제\n\n\nsudo /Library/PostgreSQL/17/uninstall-postgresql.app/Contents/MacOS/installbuilder.sh\n\n나는 17버전을 사용중이므로 이렇게 넣고 비밀번호를 입력해서 삭제를 요청했다\n\n\nEntire application을 선택해서 삭제했다.\nentire가 전체니까 모든걸 지운다는 의미인것같아서 그냥 이걸 선택했다. 그러고나니 뭔가 진행되는 듯한 느낌의 bar가 나온다.\n\n\n메시지 하나가 띡. 나온다\nThe data directory (/Library/PostgreSQL/17/data) and service user account (postgres) have not been removed.\n이 말인 즉슨, 데이터 디렉토리와 서비스 사용자 계정은 삭제되지않았으니 수동으로 삭제하라는 소리다\n\n\n데이터 디렉토리를 삭제하고 postgreSQL관련 파일을 추가 삭제한다\n\n\nsudo rm -rf /Library/PostgreSQL/17/data\n\nsudo rm -rf /Library/PostgreSQL\nsudo rm /etc/postgres-reg.ini\nsudo rm -rf ~/Library/Application\\ Support/PostgreSQL/\n\n\n\n터미널을 통한 postgres계정 삭제\n\nsudo dscl . -delete /Users/postgres\n\n\n시스템 재부팅\n\nsudo reboot\n\n정말 잘 삭제되었는지 확인하는 방법\n데이터 디렉토리 확인\nls /Library/PostgreSQL/\nls /usr/local/var/postgres\n\n프로세스 확인\npgrep postgres\n\n계정 확인\ndscl . -read /Users/postgres\n"}}