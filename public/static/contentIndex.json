{"Springboot-CRUD":{"slug":"Springboot-CRUD","filePath":"Springboot CRUD.md","title":"Springboot CRUD","links":[],"tags":[],"content":"form - dto - entity - db\n\n\narticle read\n\n\narticle create\n\n\narticle update\n\n\narticle delete\n\n\ncomment read\n\n\ncomment create\n\n\ncomment update\n\n\ncomment delete\n\n\nview\n\n\ncontroller\n\n\napi controller\n\n\nservice\n\n\n정말 잘 되고 있나?"},"index":{"slug":"index","filePath":"index.md","title":"index","links":[],"tags":[],"content":"This is a blank Quartz installation.\nSee the documentation for how to get started.\ntitle: Welcome to My Blog\nWelcome Message"},"test-content":{"slug":"test-content","filePath":"test content.md","title":"test content","links":[],"tags":[],"content":"Obsidian test.\n2025.03.25. 12:56\nquartz"},"Node-js/1.-Node-js":{"slug":"Node-js/1.-Node-js","filePath":"Node js/1. Node js.md","title":"1. Node js","links":[],"tags":[],"content":"node js의 등장으로, 원래 웹브라우저만 제어하던 javascript가 컴퓨터 자체를 제어하기 시작한다.\n재생목록\nwww.youtube.com/playlist\nproject folder\n/Users/yunhyegyeong/Developer/myNode\n목표:  node js application제작\n각각의 스텝마다 node js가 가지고있는 기능을 실행시킨다"},"Node-js/2.-URL":{"slug":"Node-js/2.-URL","filePath":"Node js/2. URL.md","title":"2. URL","links":[],"tags":[],"content":"웹애플리케이션을 구현하는 node js의 아주 중요한 테크닉.\n\nnode 에서 main.js를 실행해달라고 서버를 켜기\n3000번 포트에 나오는 내용은 정적파일이라고 볼수 있다.\n만약 1억개라면 1억개의 페이지를 만들어야겠네..\n똑같은 파일을 요청해서 받아도 뒤에 나오는 값을 달리해서 서로 다른 페이지를 받을수 있지않을까? — 무엇으로? — url의 형식에 대해 정확히 알아서 말이야.\n\nopentutorials.org:3000/main\n위 샘플 url을 분석해보자.\n\nhttp부분은 프로토콜 통신규칙. 즉, 사용자가 서버에 접속할때 어떤방식으로 접속할 것인가에 대한 이야기다. http는 웹브라우저와 웹서버가 서로 데이터를 주고받기 위해 만든 통신규칙을 말한다. 만약에 ftp를사용하면 프로토콜 통신규칙에는 ftp가 나오겠지\nopentutorial.org쪽은 도메인네임이라고도 하고, 호스트라고도 부르는데, 인터넷에 접속되어있는 각각의 컴퓨터를 말한다. 컴퓨터를 가리키는 주소라고 볼 수 있다.\n:3000은 포트번호라고 한다. 한대의 컴퓨터안에 여러개의 서버가 있을 수가 있는데, 그중에 어떤 서버와 통신할지를 말해준다. main.js 에서 우리가 listen을 3000이라고했기때문에 3000번 포트로 접속할 수 있게된다. 웹서버는 기본값이 80이라서, 생략하면 80번 포트로 들어가게 되어있다\nmain은 path이다. 접속할 때 어떤 디렉토리의 어떤 파일로 접근하는지를 말해준다\nid~~~~ 이 뒤쪽은 query string이다. 바로 우리의 주인공이다. 즉, 쿼리스트링의 값을 변경하면 우리가 웹서버에게 데이터를 전달할 수 있다. 내가 읽고싶은 정보는 html 이고,  12page로 갈것이다. 등을 전달할 수 있다. 무조건 ?으로 시작하기로 약속이 되어있다. 그리고 값과 값은 &amp;을 지정하기로 되어있다. 값의 이름과 값은 =으로 하기로 약속이 되어있다.\n\nnodejs url parse query string\nconst url = require(&#039;url&#039;);\n\nnode js가 가지고있는 수많은 기능들을 비슷한 기능으로 그룹핑한것⇒모듈\n나 지금부터 url모듈을 사용할거야. url이라는 변수를 이용해서말이야.\nconst queryData = url.parse(_url, true).query;\n\nqueryData의값이 객체로 넘어온다.   { id: html }이런식으로말이다.\nconsole.log(queryData.id)\n\n이렇게 하면 정확하게 내용이 넘어오게 되는 것이다.\nresponse.end(queryData.id);\n\n위와같이 치면 화면에 해당 아이디가 나오는 위대한 결과를 맞이할 수 있다! Wow!\n이렇게 우리는 사용자가 넘긴 데이터를 자그마치 객체로 가져와서 내가 원하는 값만 뽑아내는 일을 진행했다."},"Node-js/3.-동적-페이지-구성하기":{"slug":"Node-js/3.-동적-페이지-구성하기","filePath":"Node js/3. 동적 페이지 구성하기.md","title":"3. 동적 페이지 구성하기","links":[],"tags":[],"content":"\ntemplate라는 변수에 html전문을 넣고 한번 직관적으로 작성해보자.\nhtml전문을 넣을때 중간중간 동적으로 바뀌면 좋겠다고 생각하는 내용은 ${}의 템플릿 리터럴을 이용해서 변경한다\nhtml전문 내에서 a태그는 쿼리스트링을 이용해서 갈 수 있도록 변경한다.\n그냥 queryData.id라고 하면 예쁘지않으니까 title이라는 변수를 이용해서 값을 넣어준다.\n루트로 진입시에는 라우팅 내부를 title변수는 Welcome로 변경해주는 아이로 만들면 된다.\n\n \nconst http = require(&#039;http&#039;);\nconst fs = require(&#039;fs&#039;);\nconst url = require(&#039;url&#039;); // 요구하다. require // 나 이제 url모듈을 사용할거야. \n \nconst app = http.createServer((request,response)=&gt;{\n    let _url = request.url;\n    const queryData = url.parse(_url, true).query;\n \n    let title = queryData.id;\n    // console.log(queryData.id);\n    if(_url == &#039;/&#039;){\n      title = &#039;Welcome&#039;; // 라우팅이 /으로 들어왔을때의 내용. \n    }\n    if(_url == &#039;/favicon.ico&#039;){\n      return response.writeHead(404);\n    }\n    response.writeHead(200);\n    const template = `\n      &lt;!doctype html&gt;\n      &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;WEB1 - ${title}&lt;/title&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt;&lt;a href=&quot;/&quot;&gt;WEB&lt;/a&gt;&lt;/h1&gt;\n        &lt;ol&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=HTML&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=CSS&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=JavaScript&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;h2&gt;${title}&lt;/h2&gt;\n        &lt;p&gt;&lt;a href=&quot;www.w3.org/TR/html5/&quot; target=&quot;_blank&quot; title=&quot;html5 speicification&quot;&gt;Hypertext Markup Language (HTML)&lt;/a&gt; is the standard markup language for &lt;strong&gt;creating &lt;u&gt;web&lt;/u&gt; pages&lt;/strong&gt; and web applications.Web browsers receive HTML documents from a web server or from local storage and render them into multimedia web pages. HTML describes the structure of a web page semantically and originally included cues for the appearance of the document.\n        &lt;img src=&quot;coding.jpg&quot; width=&quot;100%&quot;&gt;\n        &lt;/p&gt;&lt;p style=&quot;margin-top:45px;&quot;&gt;HTML elements are the building blocks of HTML pages. With HTML constructs, images and other objects, such as interactive forms, may be embedded into the rendered page. It provides a means to create structured documents by denoting structural semantics for text such as headings, paragraphs, lists, links, quotes and other items. HTML elements are delineated by tags, written using angle brackets.\n        &lt;/p&gt;\n      &lt;/body&gt;\n      &lt;/html&gt;\n \n    `;\n    // console.log(__dirname+_url);\n    // response.end(fs.readFileSync(__dirname + _url));\n    response.end(template);\n \n});\napp.listen(3000);\n \n "},"Node-js/4.-file-Read":{"slug":"Node-js/4.-file-Read","filePath":"Node js/4. file Read.md","title":"4. file Read","links":[],"tags":[],"content":"nodejs file read\n현재는 타이틀은 변경이 되지만, 실제 웹페이지의 본문은 변경이 되지 않는 것을 볼 수 있다.\n이를 해결하기 위해 우리는 파일을 만들어 본문들을 관리하고, 쿼리스트링으로 요청이 들어왔을때 해당 내용에 맞는 본문을 출력해주는 시스템을 갖추면 되는 것이다.\n자, 그러면 지금부터 nodejs에서 어떻게 파일을 읽는가를 알아보자.\n위 제목처럼 nodejs file read라고 구글검색을 진행하면 공식사이트가 나온다.\nnodejs.org/api/fs.html\n공식사이트에서 수많은 모듈(nodejs에서  기본적으로 제공하는 기능들을 그룹으로 정리해둔 것)이 나온다\n여기서 참고해서 앞으로도 노드js에서 제공하는 모듈들을 사용할 수 있다\n이름안에 많은것들이 암시되어있으므로 예제를 한번 보면서 사용법을 알아내자.\n앞으로도 나는 계속 공부를 해야할 테니까말이다.\n\n파일을 다룰 때에는 파일시스템을 사용해야한다.\n\nconst fs = require(&#039;fs&#039;);\n\n이제는 파일시스템을 사용할수 있기때문에 정해진 방식대로 fs를 사용한다\n\nfs.readFile(&#039;sample.txt&#039;,(err,data)=&gt;{\n\tconsole.log(data);\n})\n\n이렇게 하고 서버를 실행해볼까?\n참고로 현재 파일시스템의 구조는 다음과 같다.\n프로젝트 폴더 &gt; nodejs &gt; fileread.js\n프로젝트 폴더 &gt; nodejs &gt; sample.txt\n이런 상태에서 이제 서버를 실행하고자 이렇게 입력했다\n\nnode nodejs/readfile \n\n\n그런데 아무 글도 읽을수가 없는거야.  undefined래. 왜일까?\n자, 생각해봐. 우리가 지금 노드를 실행시키는 폴더는 프로젝트 폴더야.\n여기서 생각했을 때 sample.txt 는 현재 폴더에 없으므로 찾을수가 없는거지.\n그래서 저 아이를 불러오려면 여기서 노드를 실행시키는 것이 아니라 nodejs폴더로 진입해서\n그 안에서 노드를실행시켜야 하더라.\n\nnode readfile\n\n\n오, 이제 나오기는 하는데 이진방식으로 나오는거야.\n\n&lt;Buffer eb 8f 99 ed 95 b4 eb ac bc ea b3 bc 20 eb b0 b1 eb 91 90 ec 82 b0 ec 9d b4 20 eb a7 88 eb a5 b4 ea b3 a0 20 eb 8b b3 eb 8f 84 eb a1 9d 20 ed 95 98 eb ... 295 more bytes&gt;\n\n\n알아 볼 수가 없는 내용이라서 우리가 알아볼 수 있게 utf-8방식으로 나오게 세팅했어\n\nconst fs = require(&quot;fs&quot;); // 파일시스템을 이제 다룰 수 있음\n \nfs.readFile(&#039;sample.txt&#039;, &#039;utf-8&#039;, (err, data)=&gt;{\n    console.log(data);\n});"},"Node-js/5.-파일로-분리한-본문-로드하기":{"slug":"Node-js/5.-파일로-분리한-본문-로드하기","filePath":"Node js/5. 파일로 분리한 본문 로드하기.md","title":"5. 파일로 분리한 본문 로드하기","links":[],"tags":[],"content":"\n\ndata라는 폴더에 각각의 본문을 넣어둔다 (확장자명은 필요없으나 파일명은 쿼리스트링으로 넘어올 값으로 지정한다)\n\n\nmain.js에서 변수로 해당내용을 치환하는 진짜 작업을 해보자\n\n\nfs.readFile()으로 값을 가지고 올것이다.\n\n\n fs.readFile(`data/${queryData.id}`,&#039;utf-8&#039;, (err, discription)=&gt;{\n \n      const template = `\n      &lt;!doctype html&gt;\n      &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;WEB1 - ${title}&lt;/title&gt;\n        &lt;meta charset=&quot;utf-8&quot;&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt;&lt;a href=&quot;/&quot;&gt;WEB&lt;/a&gt;&lt;/h1&gt;\n        &lt;ol&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=HTML&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=CSS&quot;&gt;CSS&lt;/a&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;a href=&quot;/?id=JavaScript&quot;&gt;JavaScript&lt;/a&gt;&lt;/li&gt;\n        &lt;/ol&gt;\n        &lt;h2&gt;${title}&lt;/h2&gt;\n        &lt;p&gt;${discription}&lt;/p&gt;\n      &lt;/body&gt;\n      &lt;/html&gt;\n \n      `;\n      response.end(template);\n    })\n\n위처럼  readFile로 가져온 내용을 넣어준다. template파일이나 end도 넣어준다.\n이제는 node 를 실행하고나서, 중간에 HTML파일이나 CSS파일을 수정한다면 바로바로 반영이된다. 왜냐? 요청이 올때마다 내 컴퓨터의 파일을 하나하나 읽어서 실시간으로 보여주는 것이거든\n"},"Node-js/6.-readdir":{"slug":"Node-js/6.-readdir","filePath":"Node js/6. readdir.md","title":"6. readdir","links":[],"tags":[],"content":"파일의 목록을 읽는 readdir공부하자\nconst testFolder = &#039;./data&#039;;\nconst fs = require(&#039;fs&#039;);\n \nfs.readdir(testFolder, (err, filelist)=&gt;{\n\tconsole.log(filelist);\n})\n여기서 testFolder의 경로는  node를 실행하는 그 위치를 기준으로 한다.\n따라서 지금 위 코드는  (프로젝트 폴더 &gt; nodejs)폴더 내에 있는 readdir.js파일이지만\n실제 node는 프로젝트 폴더단에서 실행하기때문에 해당 위치는 노드가 실행되는 위치를 기준으로 한다\ndata폴더는 (프로젝트폴더 &gt; data) 의 형태로 되어있어도 찾을 수가 있다는 말이다.\n만약에 쟤를 찾아들어가는거라면 ../data이렇게 적었겠지만 노드가 실행되는 위치를 기준으로 한다!!\n저 위에있는 코드를 실행시킨다면, data안에있는 파일의 목록을 배열로 출력해준다.\n\n여기까지 파일을 읽는법, 파일 목록을 읽는법을 공부했다.\n그래서 내가 할 수 있었던 일은 특정폴더에 파일이 추가됨에 따라 해당 목록을 리스트로 보여주고,\n그 내용으로 진입해서 보여줄 수 있게 해줄 수 있다.\n하나의 /라는 진입경로로 ?id라는 쿼리스트링을 이용해서 여러가지 페이지를 보여줄 수 있었고\n뿐만아니라 컴퓨터에 파일을 추가하면 알아서 새 목록으로 읽어낼 수 있게 만들어주는\n놀라운 결과를 경험한 것이다."},"Node-js/7.-synchronous--and--asynchronous":{"slug":"Node-js/7.-synchronous--and--asynchronous","filePath":"Node js/7. synchronous & asynchronous.md","title":"7. synchronous & asynchronous","links":[],"tags":[],"content":"동기와 비동기.\nnodejs는 비동기 처리를 하기위한 좋은 기능들을 많이 가지고있다\n예를 들어서 알아보자. readFile을 이용해서 파일읽기를 한번 진행해볼것이다\nreadFileSync\n그야말로 동기적인 방식으로 파일읽기를 실행한다\nconst fs = require(&#039;fs&#039;);\n \nconsole.log(&#039;A&#039;);\nconst result = fs.readFileSync(&#039;/syntax/sample.txt&#039;, &#039;utf8&#039;);\nconsole.log(result);\nconsole.log(&#039;C&#039;);\n \n위와같이 적어주면 순서대로 실행이된다.\nA\nB ( sample.txt에는 B라는 글자가 있다 )\nC\n\nreadFile\n반면에 노드에서 더 추천하기때문에 기본값으로 설정해둔 readFile을 이용해서 비동기방식으로 진행해볼까?\nconst fs = require(&#039;fs&#039;);\n \nconsole.log(&#039;A&#039;);\nfs.readFile(&#039;/syntax/sample.txt&#039;,&#039;utf8&#039;,(err, data)=&gt;{\n\tconsole.log(data);\n});\nconsole.log(&#039;C&#039;);\n리턴값을 주는 readFileSync와는 달리 readFile은 파일을 읽고 다 읽은 내용을 함수안에 넣어준다.\n위와 같이 코드를 작성하고 실행하면 그 결과는\nA\nC\nB (sample.txt의 내용)\n이와같은 형태로 나온다.\n비동기이기때문에 결과값을 가져오기전에 이미 C 를 찍어버린다는 특징이 있다\n바로 이것이 비동기방식이다.\n다 하고 나서 나중에 전화해 - 콜백"},"mysql/import-DB":{"slug":"mysql/import-DB","filePath":"mysql/import DB.md","title":"import DB","links":[],"tags":[],"content":"\nserver- data import 선택\nimport from self-contained file에서 내가 원하는 sql 파일 선택하기\ndefault target schema에서 내가 원하는 데이터베이스 선택하기\nstart import 선택하기\n\n그러면 내가 원하는 데이터를 내가 원하는 데이터베이스에 담을 수 있다.\ntables에 내가 만든 테이블들이 모두 담기고, views 같은 폴더가 별도로 있다."},"mysql/workbench-강제종료문제":{"slug":"mysql/workbench-강제종료문제","filePath":"mysql/workbench 강제종료문제.md","title":"workbench 강제종료문제","links":[],"tags":[],"content":"계속 mysql Workbench가 강제종료되는 문제가 발생했다.\nbrew install mysql\n\n꽤 긴 시간에 걸쳐 mysql을 설치 한 후에\nbrew services start mysql\n\n위 명령어를 이용해 mysql을 실행시켰다\nmysql -u root\n\n루트 계정으로 접속하고나니 Workbench에서 접속이 가능해졌다.\n\n참고로, mysql을 끄는 것은\nbrew service stop mysql\n"},"Node-js/Untitled":{"slug":"Node-js/Untitled","filePath":"Node js/Untitled.md","title":"Untitled","links":[],"tags":[],"content":""}}